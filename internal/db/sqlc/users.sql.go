// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: users.sql

package sqlc

import (
	"context"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    public_id,
    name,
    device_id,
    preferred_currency
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4
) RETURNING id, public_id, name, device_id, preferred_currency, created_at
`

type CreateUserParams struct {
	PublicID          string `json:"public_id"`
	Name              string `json:"name"`
	DeviceID          string `json:"device_id"`
	PreferredCurrency string `json:"preferred_currency"`
}

// Creates a new user with explicit ULID and returns the full record
//
//	INSERT INTO users (
//	    public_id,
//	    name,
//	    device_id,
//	    preferred_currency
//	) VALUES (
//	    ?1,
//	    ?2,
//	    ?3,
//	    ?4
//	) RETURNING id, public_id, name, device_id, preferred_currency, created_at
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.PublicID,
		arg.Name,
		arg.DeviceID,
		arg.PreferredCurrency,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.DeviceID,
		&i.PreferredCurrency,
		&i.CreatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE public_id = ?1
`

// Deletes a user by public ID
//
//	DELETE FROM users
//	WHERE public_id = ?1
func (q *Queries) DeleteUser(ctx context.Context, publicID string) error {
	_, err := q.db.ExecContext(ctx, deleteUser, publicID)
	return err
}

const getUserByDeviceID = `-- name: GetUserByDeviceID :one
SELECT id, public_id, name, device_id, preferred_currency, created_at 
FROM users
WHERE device_id = ?1 LIMIT 1
`

// Finds a user by their device ID with explicit LIMIT 1
//
//	SELECT id, public_id, name, device_id, preferred_currency, created_at
//	FROM users
//	WHERE device_id = ?1 LIMIT 1
func (q *Queries) GetUserByDeviceID(ctx context.Context, deviceID string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByDeviceID, deviceID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.DeviceID,
		&i.PreferredCurrency,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByPublicID = `-- name: GetUserByPublicID :one
SELECT id, public_id, name, device_id, preferred_currency, created_at 
FROM users
WHERE public_id = ?1 LIMIT 1
`

// Finds a user by their public ULID with explicit LIMIT 1
//
//	SELECT id, public_id, name, device_id, preferred_currency, created_at
//	FROM users
//	WHERE public_id = ?1 LIMIT 1
func (q *Queries) GetUserByPublicID(ctx context.Context, publicID string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByPublicID, publicID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.DeviceID,
		&i.PreferredCurrency,
		&i.CreatedAt,
	)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, public_id, name, device_id, preferred_currency, created_at 
FROM users
ORDER BY created_at DESC
LIMIT ?2 OFFSET ?1
`

type ListUsersParams struct {
	Offset int64 `json:"offset"`
	Limit  int64 `json:"limit"`
}

// Lists all users with explicit column selection
//
//	SELECT id, public_id, name, device_id, preferred_currency, created_at
//	FROM users
//	ORDER BY created_at DESC
//	LIMIT ?2 OFFSET ?1
func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.PublicID,
			&i.Name,
			&i.DeviceID,
			&i.PreferredCurrency,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserCurrency = `-- name: UpdateUserCurrency :one
UPDATE users
SET preferred_currency = ?1
WHERE public_id = ?2
RETURNING id, public_id, name, device_id, preferred_currency, created_at
`

type UpdateUserCurrencyParams struct {
	Currency string `json:"currency"`
	PublicID string `json:"public_id"`
}

// Updates a user's preferred currency using named parameters
//
//	UPDATE users
//	SET preferred_currency = ?1
//	WHERE public_id = ?2
//	RETURNING id, public_id, name, device_id, preferred_currency, created_at
func (q *Queries) UpdateUserCurrency(ctx context.Context, arg UpdateUserCurrencyParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserCurrency, arg.Currency, arg.PublicID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.DeviceID,
		&i.PreferredCurrency,
		&i.CreatedAt,
	)
	return i, err
}

const updateUserName = `-- name: UpdateUserName :one
UPDATE users
SET name = ?1
WHERE public_id = ?2
RETURNING id, public_id, name, device_id, preferred_currency, created_at
`

type UpdateUserNameParams struct {
	Name     string `json:"name"`
	PublicID string `json:"public_id"`
}

// Updates a user's name using named parameters
//
//	UPDATE users
//	SET name = ?1
//	WHERE public_id = ?2
//	RETURNING id, public_id, name, device_id, preferred_currency, created_at
func (q *Queries) UpdateUserName(ctx context.Context, arg UpdateUserNameParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserName, arg.Name, arg.PublicID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.PublicID,
		&i.Name,
		&i.DeviceID,
		&i.PreferredCurrency,
		&i.CreatedAt,
	)
	return i, err
}
