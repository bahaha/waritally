---
description: 
globs: 
alwaysApply: false
---
## Rule 1: Return Errors from Functions
Description: Functions should return an error as the last value to allow explicit error checking, a core Go principle. In Chi, this ensures handlers can propagate errors for proper handling.

### Good Example:
```go
package main

import (
	"fmt"
	"net/http"

	"github.com/go-chi/chi/v5"
)

func fetchUserData(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("empty user ID")
	}
	return "user data", nil
}

func getUser(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	data, err := fetchUserData(id)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	w.Write([]byte(data))
}

func main() {
	r := chi.NewRouter()
	r.Get("/user/{id}", getUser)
	http.ListenAndServe(":8080", r)
}
```

### Bad Example
```go
package main

import (
	"net/http"

	"github.com/go-chi/chi/v5"
)

func fetchUserData(id string) string { // Bad: No error return
	if id == "" {
		return "error: empty ID" // No way to distinguish error from data
	}
	return "user data"
}

func getUser(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	data := fetchUserData(id) // No error checking possible
	w.Write([]byte(data))
}

func main() {
	r := chi.NewRouter()
	r.Get("/user/{id}", getUser)
	http.ListenAndServe(":8080", r)
}
```

## Rule 2: Always Check for Errors
Description: Explicitly check if an error is not nil after calling a function that returns an error. In Chi, this prevents silent failures in handlers.

### Good Example:
```go
package main

import (
	"net/http"

	"github.com/go-chi/chi/v5"
)

func processRequest(w http.ResponseWriter, r *http.Request) {
	body, err := io.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "failed to read request body", http.StatusBadRequest)
		return
	}
	w.Write(body)
}

func main() {
	r := chi.NewRouter()
	r.Post("/process", processRequest)
	http.ListenAndServe(":8080", r)
}
```

### Bad Example
```go
package main

import (
	"io"
	"net/http"

	"github.com/go-chi/chi/v5"
)

func processRequest(w http.ResponseWriter, r *http.Request) {
	body, _ := io.ReadAll(r.Body) // Bad: Ignoring error with blank identifier
	w.Write(body)                 // May crash if body is nil
}

func main() {
	r := chi.NewRouter()
	r.Post("/process", processRequest)
	http.ListenAndServe(":8080", r)
}
```

## Rule 3: Wrap Errors for Context
Description: Use fmt.Errorf with %w to wrap errors, adding context for debugging. In Chi, this helps log detailed errors while sending user-friendly responses.

### Good Example:
```go
package main

import (
	"fmt"
	"net/http"

	"github.com/go-chi/chi/v5"
)

func queryDB(id string) (string, error) {
	if id == "0" {
		return "", fmt.Errorf("invalid ID: %s", id)
	}
	return "data", nil
}

func getData(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	data, err := queryDB(id)
	if err != nil {
		log.Printf("getData failed: %w", err) // Wrap for logging
		http.Error(w, "invalid request", http.StatusBadRequest)
		return
	}
	w.Write([]byte(data))
}

func main() {
	r := chi.NewRouter()
	r.Get("/data/{id}", getData)
	http.ListenAndServe(":8080", r)
}
```

### Bad Example
```go
package main

import (
	"fmt"
	"net/http"

	"github.com/go-chi/chi/v5"
)

func queryDB(id string) (string, error) {
	if id == "0" {
		return "", fmt.Errorf("invalid ID") // No specific context
	}
	return "data", nil
}

func getData(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	data, err := queryDB(id)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest) // Bad: No wrapping, vague error
		return
	}
	w.Write([]byte(data))
}

func main() {
	r := chi.NewRouter()
	r.Get("/data/{id}", getData)
	http.ListenAndServe(":8080", r)
}
```

## Rule 4: Use Defer for Resource Cleanup
Description: Use defer to ensure resources (e.g., files, connections) are closed, even if an error occurs. In Chi, this maintains stability in handlers.

### Good Example:
```go
package main

import (
	"net/http"
	"os"

	"github.com/go-chi/chi/v5"
)

func readFile(w http.ResponseWriter, r *http.Request) {
	file, err := os.Open("data.txt")
	if err != nil {
		http.Error(w, "failed to open file", http.StatusInternalServerError)
		return
	}
	defer file.Close() // Ensures cleanup
	w.Write([]byte("file opened"))
}

func main() {
	r := chi.NewRouter()
	r.Get("/file", readFile)
	http.ListenAndServe(":8080", r)
}
```
### Bad Example
```go
package main

import (
	"net/http"
	"os"

	"github.com/go-chi/chi/v5"
)

func readFile(w http.ResponseWriter, r *http.Request) {
	file, err := os.Open("data.txt")
	if err != nil {
		http.Error(w, "failed to open file", http.StatusInternalServerError)
		return
	}
	// Bad: No defer, file remains open
	w.Write([]byte("file opened"))
}

func main() {
	r := chi.NewRouter()
	r.Get("/file", readFile)
	http.ListenAndServe(":8080", r)
}
```

## Rule 5: Use Custom Error Types for Web
Description: Define custom error types with HTTP status codes and messages for specific handling in Chi, improving user feedback and logging.

### Good Example:
```go
package main

import (
	"fmt"
	"net/http"

	"github.com/go-chi/chi/v5"
)

type appError struct {
	Message string
	Status  int
}

func (e *appError) Error() string {
	return e.Message
}

func fetchResource(id string) (string, error) {
	if id == "" {
		return "", &appError{"missing resource ID", http.StatusBadRequest}
	}
	return "resource", nil
}

func getResource(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	data, err := fetchResource(id)
	if err != nil {
		if appErr, ok := err.(*appError); ok {
			http.Error(w, appErr.Message, appErr.Status)
			return
		}
		http.Error(w, "internal error", http.StatusInternalServerError)
		return
	}
	w.Write([]byte(data))
}

func main() {
	r := chi.NewRouter()
	r.Get("/resource/{id}", getResource)
	http.ListenAndServe(":8080", r)
}
```

### Bad Example
```go
package main

import (
	"fmt"
	"net/http"

	"github.com/go-chi/chi/v5"
)

func fetchResource(id string) (string, error) {
	if id == "" {
		return "", fmt.Errorf("missing ID") // Bad: No status or structure
	}
	return "resource", nil
}

func getResource(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	data, err := fetchResource(id)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError) // All errors as 500
		return
	}
	w.Write([]byte(data))
}

func main() {
	r := chi.NewRouter()
	r.Get("/resource/{id}", getResource)
	http.ListenAndServe(":8080", r)
}
```

## Rule 6: Log Errors Appropriately
Description: Log detailed errors internally for debugging, while sending generic messages to users to avoid exposing sensitive data in Chi.

### Good Example:
```go
package main

import (
	"fmt"
	"log"
	"net/http"

	"github.com/go-chi/chi/v5"
)

func processData(w http.ResponseWriter, r *http.Request) {
	body, err := io.ReadAll(r.Body)
	if err != nil {
		log.Printf("processData failed: %w", err) // Log detailed error
		http.Error(w, "invalid request", http.StatusBadRequest) // Generic user message
		return
	}
	w.Write(body)
}

func main() {
	r := chi.NewRouter()
	r.Post("/data", processData)
	http.ListenAndServe(":8080", r)
}
```

### Bad Example
```go
package main

import (
	"io"
	"net/http"

	"github.com/go-chi/chi/v5"
)

func processData(w http.ResponseWriter, r *http.Request) {
	body, err := io.ReadAll(r.Body)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest) // Bad: Exposes raw error to user
		return
	}
	w.Write(body)
}

func main() {
	r := chi.NewRouter()
	r.Post("/data", processData)
	http.ListenAndServe(":8080", r)
}
```

## Rule 7: Avoid Panics for Expected Errors
Description: Return errors instead of panicking for expected issues (e.g., invalid input). In Chi, use http.Error for control flow instead of panics.

### Good Example:
```go
package main

import (
	"net/http"

	"github.com/go-chi/chi/v5"
)

func validateInput(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	if id == "" {
		http.Error(w, "missing ID", http.StatusBadRequest)
		return
	}
	w.Write([]byte("valid input"))
}

func main() {
	r := chi.NewRouter()
	r.Get("/validate/{id}", validateInput)
	http.ListenAndServe(":8080", r)
}
```

### Bad Example
```go
package main

import (
	"net/http"

	"github.com/go-chi/chi/v5"
)

func validateInput(w http.ResponseWriter, r *http.Request) {
	id := chi.URLParam(r, "id")
	if id == "" {
		panic("missing ID") // Bad: Panic for expected error
	}
	w.Write([]byte("valid input"))
}

func main() {
	r := chi.NewRouter()
	r.Get("/validate/{id}", validateInput)
	http.ListenAndServe(":8080", r)
}
```