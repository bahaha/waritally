---
description: 
globs: 
alwaysApply: false
---
## Rule 1: Use a Centralized Bundle for Translations
Description: Initialize a single i18n.Bundle at the start of your application and load all translation files into it. This ensures that translations are loaded only once and are accessible throughout the application.

## Good Example:
```go
package main

import (
    "encoding/json"
    "github.com/nicksnyder/go-i18n/v2/i18n"
    "golang.org/x/text/language"
)

var bundle *i18n.Bundle

func init() {
    bundle = i18n.NewBundle(language.English)
    bundle.RegisterUnmarshalFunc("json", json.Unmarshal)
    bundle.MustLoadMessageFile("locales/en.json")
    bundle.MustLoadMessageFile("locales/es.json")
}

func main() {
    // Bundle is now accessible throughout the application
}
```

## Bad Example:
```go
package main

import (
    "encoding/json"
    "github.com/nicksnyder/go-i18n/v2/i18n"
    "golang.org/x/text/language"
)

func main() {
    bundle := i18n.NewBundle(language.English)
    bundle.RegisterUnmarshalFunc("json", json.Unmarshal)
    bundle.MustLoadMessageFile("locales/en.json")
    bundle.MustLoadMessageFile("locales/es.json")
    // Bundle is only accessible within main, limiting its use in larger applications
}
```

## Rule 2: Create Localizers Per Request
Description: For web applications, create a new i18n.Localizer for each request based on the user's locale preference. This ensures that each request gets the correct translations tailored to the user’s language.

## Good Example:
```go
func greetHandler(w http.ResponseWriter, r *http.Request) {
    lang := r.URL.Query().Get("lang")
    if lang == "" {
        lang = "en"
    }
    localizer := i18n.NewLocalizer(bundle, lang)
    // Use localizer to get translations for this specific request
}
```

## Bad Example:
```go
var localizer *i18n.Localizer

func init() {
    localizer = i18n.NewLocalizer(bundle, "en")
}

func greetHandler(w http.ResponseWriter, r *http.Request) {
    // Using a global localizer ignores the user's locale preference
    msg, _ := localizer.Localize(&i18n.LocalizeConfig{MessageID: "greeting"})
    fmt.Fprintf(w, msg)
}
```

## Rule 3: Use Message IDs, Not Hardcoded Strings
Description: Always reference translations by their message IDs instead of hardcoded strings. This keeps your code language-agnostic and simplifies translation management.

## Good Example:
```go
msg, err := localizer.Localize(&i18n.LocalizeConfig{
    MessageID: "greeting",
    TemplateData: map[string]interface{}{
        "Name": name,
    },
})
```

## Bad Example:
```go
// Assuming translations are stored in a map or similar structure
msg := translations[lang]["Hello, {{.Name}}!"]
// Hardcoding strings ties the code to specific languages, complicating updates
```

## Rule 4: Handle Locale Preferences Flexibly
Description: Determine locale preferences from multiple sources (e.g., query parameters, Accept-Language headers, or cookies) and provide a fallback to a default language for robustness.

## Good Example:
```go
func getLocale(r *http.Request) string {
    // Check query param first
    lang := r.URL.Query().Get("lang")
    if lang != "" {
        return lang
    }
    // Then check Accept-Language header
    accept := r.Header.Get("Accept-Language")
    if accept != "" {
        // Simplified: returns the first language in the header
        return strings.Split(accept, ",")[0]
    }
    // Fallback to default language
    return "en"
}
```

## Bad Example:
```go
func getLocale(r *http.Request) string {
    // Only checks query param with no fallback
    return r.URL.Query().Get("lang")
}
// Fails if lang isn’t provided, leading to potential errors
```

## Rule 5: Structure Translation Files Consistently
Description: Store translation files in a dedicated directory (e.g., locales) with consistent naming (e.g., en.json, es.json). Use unique message IDs for each translation.

## Good Example:
```text
locales/
├── en.json
│   {
│     "greeting": {
│       "id": "greeting",
│       "translation": "Hello, {{.Name}}!"
│     }
│   }
└── es.json
    {
      "greeting": {
        "id": "greeting",
        "translation": "¡Hola, {{.Name}}!"
      }
    }
```

## Bad Example:
```text
translations/
├── english.txt
│   Hello, {{.Name}}!
└── spanish.txt
    ¡Hola, {{.Name}}!
// Unstructured files without message IDs are harder to manage
```

## Rule 6: Use Placeholders for Dynamic Data
Description: Use text/template syntax placeholders (e.g., {{.Name}}) in translation strings for dynamic data, leveraging Go’s native templating for flexibility.

## Good Example:
```json
{
  "greeting": {
    "id": "greeting",
    "translation": "Hello, {{.Name}}!"
  }
}
```

## Bad Example:
```json
{
  "greeting": {
    "id": "greeting",
    "translation": "Hello, %s!" // printf-style is less flexible and less idiomatic in Go
  }
}
```

## Rule 7: Handle Pluralization When Necessary
Description: Use the i18n library’s pluralization features for messages involving counts, ensuring correct forms for different languages and quantities.

## Good Example:
```json
{
  "apples": {
    "id": "apples",
    "translation": {
      "one": "I have {{.Count}} apple.",
      "other": "I have {{.Count}} apples."
    }
  }
}
```

```go
msg, err := localizer.Localize(&i18n.LocalizeConfig{
    MessageID:   "apples",
    PluralCount: count,
    TemplateData: map[string]interface{}{
        "Count": count,
    },
})
```

## Bad Example:
```go
if count == 1 {
    msg = "I have 1 apple."
} else {
    msg = fmt.Sprintf("I have %d apples.", count)
}
// Manual plural handling is error-prone and doesn’t support complex plural rules
```

## Rule 8: Test Translations Regularly
Description: Write tests to verify that translations load correctly and return the expected messages for different locales, catching issues early.

## Good Example:
```go
func TestGreeting(t *testing.T) {
    localizer := i18n.NewLocalizer(bundle, "en")
    msg, err := localizer.Localize(&i18n.LocalizeConfig{
        MessageID: "greeting",
        TemplateData: map[string]interface{}{
            "Name": "Alice",
        },
    })
    assert.NoError(t, err)
    assert.Equal(t, "Hello, Alice!", msg)
}
```

## Bad Example:
```go
// No tests, assuming translations work
// Risks undetected bugs as the application scales
```