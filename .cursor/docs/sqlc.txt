This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: docs/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
docs/
  _static/
    customize.css
  _templates/
    breadcrumbs.html
    layout.html
  guides/
    development.md
    migrating-off-hosted-managed-databases.md
    migrating-to-sqlc-gen-kotlin.md
    migrating-to-sqlc-gen-python.md
    plugins.md
    privacy.md
    using-go-and-pgx.rst
  howto/
    ci-cd.md
    ddl.md
    delete.md
    embedding.md
    generate.md
    insert.md
    managed-databases.md
    named_parameters.md
    overrides.md
    prepared_query.md
    push.md
    query_count.md
    rename.md
    select.md
    structs.md
    transactions.md
    update.md
    verify.md
    vet.md
  overview/
    install.md
  reference/
    changelog.md
    cli.md
    config.md
    datatypes.md
    environment-variables.md
    language-support.rst
    macros.md
    query-annotations.md
  tutorials/
    getting-started-mysql.md
    getting-started-postgresql.md
    getting-started-sqlite.md
  .gitignore
  conf.py
  index.rst
  Makefile
  requirements.txt

================================================================
Files
================================================================

================
File: docs/_static/customize.css
================
.wy-side-nav-search img {
  padding: 5px 60px !important;
}

#banner {
  text-align: center;
  background: #2980b9;
  border: 1px solid rgb(52, 49, 49);
  color: #F0F0F4;
  padding: 10px;
  margin-bottom: 1.618em;
}

#banner > div > a {
  color: #F0F0F4;
  text-decoration: underline;
}

#sponsorship > img {
  width: 100%;
  max-width: 200px;
}

================
File: docs/_templates/breadcrumbs.html
================
{% extends "!breadcrumbs.html" %}

{% block breadcrumbs %}
{% if show_banner %}
{% endif %}
{{ super() }}
{% endblock %}

================
File: docs/_templates/layout.html
================
{% extends "!layout.html" %}

{% block extrahead %}
<script defer data-domain="docs.sqlc.dev" data-api="https://proxy.sqlc.dev/api/event" src="https://proxy.sqlc.dev/js/script.js"></script>
{{ super() }}
{% endblock %}

{% block menu %}
{{ super() }}
<p class="caption" role="heading"><span class="caption-text">Sponsored By</span></p>
<div>
<a id="sponsorship" href="https://riza.io?utm_source=sqlc+docs">
<img src="https://sqlc.dev/sponsors/riza-readme.png" alt="Riza logo" />
</a>
</div>
{% endblock %}

================
File: docs/guides/development.md
================
# Developing sqlc

## Building

For local development, install `sqlc` under an alias. We suggest `sqlc-dev`.

```
go build -o ~/go/bin/sqlc-dev ./cmd/sqlc
```

Install `sqlc-gen-json` to avoid test failure.

```
go build -o ~/go/bin/sqlc-gen-json ./cmd/sqlc-gen-json
```

## Running Tests

```
go test ./...
```

To run the tests in the examples folder, use the `examples` tag.

```
go test --tags=examples ./...
```

These tests require locally-running database instances. Run these databases
using [Docker Compose](https://docs.docker.com/compose/).

```
docker compose up -d
```

The tests use the following environment variables to connect to the
database

### For PostgreSQL

```
Variable     Default Value
-------------------------
PG_HOST      127.0.0.1
PG_PORT      5432
PG_USER      postgres
PG_PASSWORD  mysecretpassword
PG_DATABASE  dinotest
```

### For MySQL

```
Variable     Default Value
-------------------------
MYSQL_HOST      127.0.0.1
MYSQL_PORT      3306
MYSQL_USER      root
MYSQL_ROOT_PASSWORD  mysecretpassword
MYSQL_DATABASE  dinotest
```

================
File: docs/guides/migrating-off-hosted-managed-databases.md
================
# Migrating off hosted managed databases
 
Starting in sqlc 1.27.0, [managed databases](../docs/managed-databases.md) will require a database server URI in the configuration file.

This guide walks you through migrating to a locally running database server.

## Run a database server locally

There are many options for running a database server locally, but this guide
will use [Docker Compose](https://docs.docker.com/compose/), as it can support
both MySQL and PostgreSQL.

If you're using macOS and PostgreSQL, [Postgres.app](https://postgresapp.com/) is also a good option.

For MySQL, create a `docker-compose.yml` file with the following contents:

```yaml
version: "3.8"
services:
  mysql:
    image: "mysql/mysql-server:8.0"
    ports:
      - "3306:3306"
    restart: always
    environment:
      MYSQL_DATABASE: dinotest
      MYSQL_ROOT_PASSWORD: mysecretpassword
      MYSQL_ROOT_HOST: '%'
```

For PostgreSQL, create a `docker-compose.yml` file with the following contents:

```yaml
version: "3.8"
services:
  postgresql:
    image: "postgres:16"
    ports:
      - "5432:5432"
    restart: always
    environment:
      POSTGRES_DB: postgres
      POSTGRES_PASSWORD: mysecretpassword
      POSTGRES_USER: postgres
```

```sh
docker compose up -d
```

## Upgrade sqlc

You must be running sqlc v1.28.0 or greater to have access to the `servers`
configuration.

## Add servers to configuration

```diff
version: '2'
cloud:
  project: '<PROJECT_ID>'
+ servers:
+ - name: mysql
+   uri: mysql://localhost:3306
+ - name: postgres
+   uri: postgres://localhost:5432/postgres?sslmode=disable
```

## Re-generate the code

Run `sqlc generate`. A database with the `sqlc_managed_` prefix will be automatically created and used for query analysis.

================
File: docs/guides/migrating-to-sqlc-gen-kotlin.md
================
# Migrating to sqlc-gen-kotlin
 
Starting in sqlc 1.16.0, built-in Kotlin support has been deprecated. It will
be fully removed in 1.17.0 in favor of sqlc-gen-kotlin.

This guide will walk you through migrating to the [sqlc-gen-kotlin](https://github.com/sqlc-dev/sqlc-gen-kotlin) plugin,
which involves three steps.

1. Add the sqlc-gen-kotlin plugin
2. Migrate each package
3. Re-generate the code

## Add the sqlc-gen-kotlin plugin

In your configuration file, add a `plugins` array if you don't have one
already. Add the following configuration for the plugin:

```json
{
  "version": "2",
  "plugins": [
    {
      "name": "kt",
      "wasm": {
        "url": "https://downloads.sqlc.dev/plugin/sqlc-gen-kotlin_1.0.0.wasm",
        "sha256": "7620dc5d462de41fdc90e2011232c842117b416c98fd5c163d27c5738431a45c"
      }
    }
  ]
}
```

```yaml
version: "2"
plugins:
- name: "kt"
  wasm:
    url: "https://downloads.sqlc.dev/plugin/sqlc-gen-kotlin_1.0.0.wasm"
    sha256: "7620dc5d462de41fdc90e2011232c842117b416c98fd5c163d27c5738431a45c"
```

## Migrate each package

Your package configuration should currently looks something like this for JSON.

```json
  "sql": [
    {
      "schema": "schema.sql",
      "queries": "query.sql",
      "engine": "postgresql",
      "gen": {
        "kotlin": {
          "out": "src/main/kotlin/com/example/foo",
          "package": "com.example.foo"
        }
      }
    }
  ]
```

Or this if you're using YAML.

```yaml
  sql:
  - schema: "schema.sql"
    queries: "query.sql"
    engine: "postgresql"
    gen:
      kotlin:
        out: "src/main/kotlin/com/example/foo"
        package: "com.example.foo"
```

To use the plugin, you'll need to replace the `gen` mapping with the `codegen`
collection. Add the `plugin` field, setting it to `kt`. All fields other than
`out` need to be moved into the `options` mapping.

After you're done, it should look like this for JSON.

```json
  "sql": [
    {
      "schema": "schema.sql",
      "queries": "query.sql",
      "engine": "postgresql",
      "codegen": [
        {
          "out": "src/main/kotlin/com/example/foo",
          "plugin": "kt",
          "options": {
            "package": "com.example.foo"
          }
        }
      ]
    }
  ]
```

Or this for YAML.

```yaml
  sql:
  - schema: "schema.sql"
    queries: "query.sql"
    engine: "postgresql"
    codegen:
    - plugin: "kt"
      out: "src/main/kotlin/com/example/foo"
      options:
        package: "com.example.foo"
```

## Re-generate the code

Run `sqlc generate`. The plugin will produce the same output, so you shouldn't
see any changes. The first time `sqlc generate` is run, the plugin must be
downloaded and compiled, resulting in a slightly longer runtime. Subsequent
`generate` calls will be fast.

================
File: docs/guides/migrating-to-sqlc-gen-python.md
================
# Migrating to sqlc-gen-python
 
Starting in sqlc 1.16.0, built-in Python support has been deprecated. It will
be fully removed in 1.17.0 in favor of sqlc-gen-python.

This guide will walk you through migrating to the [sqlc-gen-python](https://github.com/sqlc-dev/sqlc-gen-python) plugin,
which involves three steps.

1. Add the sqlc-gen-python plugin
2. Migrate each package
3. Re-generate the code

## Add the sqlc-gen-python plugin

In your configuration file, add a `plugins` array if you don't have one
already. Add the following configuration for the plugin:

```json
{
  "version": "2",
  "plugins": [
    {
      "name": "py",
      "wasm": {
        "url": "https://downloads.sqlc.dev/plugin/sqlc-gen-python_1.0.0.wasm",
        "sha256": "aca83e1f59f8ffdc604774c2f6f9eb321a2b23e07dc83fc12289d25305fa065b"
      }
    }
  ]
}
```

```yaml
version: "2"
plugins:
  - name: "py"
    wasm:
      url: "https://downloads.sqlc.dev/plugin/sqlc-gen-python_1.0.0.wasm"
      sha256: "aca83e1f59f8ffdc604774c2f6f9eb321a2b23e07dc83fc12289d25305fa065b"
```

## Migrate each package

Your package configuration should currently looks something like this for JSON.

```json
  "sql": [
    {
      "schema": "schema.sql",
      "queries": "query.sql",
      "engine": "postgresql",
      "gen": {
        "python": {
          "out": "src",
          "package": "foo",
          "emit_sync_querier": true,
          "emit_async_querier": true,
          "query_parameter_limit": 5
        }
      }
    }
  ]
```

Or this if you're using YAML.

```yaml
  sql:
  - schema: "schema.sql"
    queries: "query.sql"
    engine: "postgresql"
    gen:
      python:
        out: "src"
        package: "foo"
        emit_sync_querier: true
        emit_async_querier: true
        query_parameter_limit: 5
```

To use the plugin, you'll need to replace the `gen` mapping with the `codegen`
collection. Add the `plugin` field, setting it to `py`. All fields other than
`out` need to be moved into the `options` mapping.

After you're done, it should look like this for JSON.

```json
  "sql": [
    {
      "schema": "schema.sql",
      "queries": "query.sql",
      "engine": "postgresql",
      "codegen": [
        {
          "out": "src",
          "plugin": "py",
          "options": {
            "package": "authors",
            "emit_sync_querier": true,
            "emit_async_querier": true,
            "query_parameter_limit": 5
          }
        }
      ]
    }
  ]
```

Or this for YAML.

```yaml
  sql:
  - schema: "schema.sql"
    queries: "query.sql"
    engine: "postgresql"
    codegen:
    - plugin: "py"
      out: "src"
      options:
        package: "foo"
        emit_sync_querier: true
        emit_async_querier: true
        query_parameter_limit: 5
```

## Re-generate the code

Run `sqlc generate`. The plugin will produce the same output, so you shouldn't
see any changes. The first time `sqlc generate` is run, the plugin must be
downloaded and compiled, resulting in a slightly longer runtime. Subsequent
`generate` calls will be fast.

================
File: docs/guides/plugins.md
================
# Using plugins

To use plugins, you must be using [Version 2](../reference/config.md#version-2) of
the configuration file. The top-level `plugins` array defines the available
plugins.

## WASM plugins

> WASM plugins are fully sandboxed; they do not have access to the network,
> filesystem, or environment variables.

In the `codegen` section, the `out` field dictates what directory will contain
the new files. The `plugin` key must reference a plugin defined in the
top-level `plugins` map. Any `options` are serialized to a string as JSON and
passed on to the plugin itself.


```yaml
version: '2'
plugins:
- name: greeter
  wasm:
    url: https://github.com/sqlc-dev/sqlc-gen-greeter/releases/download/v0.1.0/sqlc-gen-greeter.wasm
    sha256: afc486dac2068d741d7a4110146559d12a013fd0286f42a2fc7dcd802424ad07
sql:
- schema: schema.sql
  queries: query.sql
  engine: postgresql
  codegen:
  - out: gen
    plugin: greeter
    options:
      lang: en-US
```

For a complete working example see the following files:
- [sqlc-gen-greeter](https://github.com/sqlc-dev/sqlc-gen-greeter)
  - A WASM plugin (written in Rust) that outputs a friendly message
- [wasm_plugin_sqlc_gen_greeter](https://github.com/sqlc-dev/sqlc/tree/main/internal/endtoend/testdata/wasm_plugin_sqlc_gen_greeter)
  - An example project showing how to use a WASM plugin

## Process plugins

> Process-based plugins offer minimal security. Only use plugins that you
> trust. Better yet, only use plugins that you've written yourself.

In the `codegen` section, the `out` field dictates what directory will contain
the new files. The `plugin` key must reference a plugin defined in the
top-level `plugins` map. Any `options` are serialized to a string as JSON and
passed on to the plugin itself.

```yaml
version: '2'
plugins:
- name: jsonb
  process:
    cmd: sqlc-gen-json
sql:
- schema: schema.sql
  queries: query.sql
  engine: postgresql
  codegen:
  - out: gen
    plugin: jsonb
    options:
      indent: "  "
      filename: codegen.json
```

For a complete working example see the following files:
- [sqlc-gen-json](https://github.com/sqlc-dev/sqlc/tree/main/cmd/sqlc-gen-json)
  - A process-based plugin that serializes the CodeGenRequest to JSON
- [process_plugin_sqlc_gen_json](https://github.com/sqlc-dev/sqlc/tree/main/internal/endtoend/testdata/process_plugin_sqlc_gen_json)
  - An example project showing how to use a process-based plugin
- [process_plugin_sqlc_gen_json](https://github.com/sqlc-dev/sqlc/tree/main/internal/endtoend/testdata/process_plugin_format_json/)
  - An example project showing how to use a process-based plugin using json

## Environment variables

By default, plugins do not inherit access to environment variables. Instead,
you can configure access on a per-variable basis. For example, if your plugin
needs the `PATH` environment variable, add `PATH` to the `env` list in the
`plugins` collection.

```yaml
version: '2'
sql:
- schema: schema.sql
  queries: query.sql
  engine: postgresql
  codegen:
  - out: gen
    plugin: test
plugins:
- name: test
  env:
  - PATH
  wasm:
    url: https://github.com/sqlc-dev/sqlc-gen-test/releases/download/v0.1.0/sqlc-gen-test.wasm
    sha256: 138220eae508d4b65a5a8cea555edd155eb2290daf576b7a8b96949acfeb3790
```

A variable named `SQLC_VERSION` is always included in the plugin's
environment, set to the version of the `sqlc` executable invoking it.

================
File: docs/guides/privacy.md
================
# Privacy and data collection

These days, it feels like every piece of software is tracking you. From your
browser, to your phone, to your terminal, programs collect as much data about
you as possible and send it off to the cloud for analysis.

We believe the best way to keep data safe is to never collect it in the first
place.

## Our Privacy Pledge

The `sqlc` command line tool does not collect any information. It
does not send crash reports to a third-party. It does not gather anonymous
aggregate user behaviour analytics.

No analytics. 
No finger-printing.
No tracking.

Not now and not in the future.

### Distribution Channels

We distribute sqlc using popular package managers such as
[Homebrew](https://brew.sh/) and [Snapcraft](https://snapcraft.io/). These
package managers and their associated command-line tools do collect usage
metrics.

We use these services to make it easy to for users to install sqlc. There will
always be an option to download sqlc from a stable URL.

## Hosted Services

We provide a few hosted services in addition to the sqlc command line tool.

### sqlc.dev

* Hosted on [GitHub Pages](https://pages.github.com/)
* Analytics with [Plausible](https://plausible.io/privacy-focused-web-analytics)

### docs.sqlc.dev

* Hosted on [Read the Docs](https://readthedocs.org/)
* Analytics with [Plausible](https://plausible.io/privacy-focused-web-analytics)

### play.sqlc.dev

* Hosted on [Heroku](https://heroku.com)
* Playground data stored in [Google Cloud Storage](https://cloud.google.com/storage)
  * Automatically deleted after 30 days

### app.sqlc.dev / api.sqlc.dev

* Hosted on [Heroku](https://heroku.com)
* Error tracking and tracing with [Sentry](https://sentry.io)

================
File: docs/guides/using-go-and-pgx.rst
================
================
Using Go and pgx
================

.. note::
   :code:`pgx/v5` is supported starting from v1.18.0.


pgx is a pure Go driver and toolkit for PostgreSQL. It's become the default
PostgreSQL package for many Gophers since lib/pq was put into maintenance mode.

^^^^^^^^^^^^^^^
Getting started
^^^^^^^^^^^^^^^

To start generating code that uses pgx, set the :code:`sql_package` field in
your :code:`sqlc.yaml` configuration file. Valid options are :code:`pgx/v4` or
:code:`pgx/v5`

.. code-block:: yaml

    version: "2"
    sql:
      - engine: "postgresql"
        queries: "query.sql"
        schema: "query.sql"
        gen:
          go:
            package: "db"
            sql_package: "pgx/v5"
            out: "db"

If you don't have an existing sqlc project on hand, create a directory with the
configuration file above and the following :code:`query.sql` file.

.. code-block:: sql

    CREATE TABLE authors (
      id   BIGSERIAL PRIMARY KEY,
      name text      NOT NULL,
      bio  text
    );

    -- name: GetAuthor :one
    SELECT * FROM authors
    WHERE id = $1 LIMIT 1;
    
    -- name: ListAuthors :many
    SELECT * FROM authors
    ORDER BY name;
    
    -- name: CreateAuthor :one
    INSERT INTO authors (
      name, bio
    ) VALUES (
      $1, $2
    )
    RETURNING *;
    
    -- name: DeleteAuthor :exec
    DELETE FROM authors
    WHERE id = $1;


Generating the code will now give you pgx-compatible database access methods.

.. code-block:: bash

   sqlc generate

^^^^^^^^^^^^^^^^^^^^^^^^^^
Generated code walkthrough
^^^^^^^^^^^^^^^^^^^^^^^^^^

The generated code is very similar to the code generated when using
:code:`lib/pq`. However, instead of using :code:`database/sql`, the code uses
pgx types directly.

.. code-block:: go

    package main
    
    import (
    	"context"
    	"fmt"
    	"os"
    
    	"github.com/jackc/pgx/v5"
        
    	"example.com/sqlc-tutorial/db"
    )
    
    func main() {
    	// urlExample := "postgres://username:password@localhost:5432/database_name"
    	conn, err := pgx.Connect(context.Background(), os.Getenv("DATABASE_URL"))
    	if err != nil {
    		fmt.Fprintf(os.Stderr, "Unable to connect to database: %v\n", err)
    		os.Exit(1)
    	}
    	defer conn.Close(context.Background())

    	q := db.New(conn)
    
    	author, err := q.GetAuthor(context.Background(), 1)
    	if err != nil {
    		fmt.Fprintf(os.Stderr, "GetAuthor failed: %v\n", err)
    		os.Exit(1)
    	}
    
    	fmt.Println(author.Name)
    }

================
File: docs/howto/ci-cd.md
================
# Using sqlc in CI/CD

If your project has more than a single developer, we suggest running `sqlc` as
part of your CI/CD pipeline. The four subcommands you'll want to run are `diff`,
`vet`, `verify` and `push`

`sqlc diff` ensures that your generated code is up to date. New developers to a
project may forget to run `sqlc generate` after adding a query or updating a
schema. They also might edit generated code. `sqlc diff` will catch both errors
by comparing the expected output from `sqlc generate` to what's on disk.

```diff
% sqlc diff
--- a/postgresql/query.sql.go
+++ b/postgresql/query.sql.go
@@ -55,7 +55,7 @@

 const listAuthors = `-- name: ListAuthors :many
 SELECT id, name, bio FROM authors
-ORDER BY name
+ORDER BY bio
 `
```

`sqlc vet` runs a set of lint rules against your SQL queries. These rules are
helpful in catching anti-patterns before they make it into production. Please
see the [vet](vet.md) documentation for a complete guide to adding lint rules
for your project.

`sqlc verify` ensures that schema changes do not break production. Existing
queries are checked against new schema changes for correctness. Please see the
[verify](verify.md) documentation for a complete guide.


`sqlc push` pushes your database schema, queries and configuration to sqlc
Cloud. These archives are used by `verify` to catch breaking changes to your
database schema.  Learn more about uploading projects [here](push.md)

## General setup

Install `sqlc` using the [suggested instructions](../overview/install).

Create three steps in your pipeline for `sqlc diff`, `sqlc vet`, and `sqlc
verify`. Run `sqlc push` after merge on your `main` branch.

## GitHub Actions

We provide the [setup-sqlc](https://github.com/marketplace/actions/setup-sqlc)
GitHub Action to install `sqlc`. The action uses the built-in
[tool-cache](https://github.com/actions/toolkit/blob/main/packages/tool-cache/README.md)
to speed up the installation process.

### diff

The following GitHub Workflow configuration runs `sqlc diff` on every push.

```yaml
name: sqlc
on: [push]
jobs:
  diff:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: sqlc-dev/setup-sqlc@v3
      with:
        sqlc-version: '1.28.0'
    - run: sqlc diff
```

### vet

The following GitHub Workflow configuration runs [sqlc vet](vet.md) on every push.
You can use `sqlc vet` without a database connection, but you'll need one if your
`sqlc` configuration references the built-in `sqlc/db-prepare` lint rule.

```yaml
name: sqlc
on: [push]
jobs:
  vet:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: sqlc-dev/setup-sqlc@v3
      with:
        sqlc-version: '1.28.0'
    # Start a PostgreSQL server
    - uses: sqlc-dev/action-setup-postgres@master
      with:
        postgres-version: "16"
      id: postgres
    - run: sqlc vet
      env:
        POSTGRESQL_SERVER_URI: ${{ steps.postgres.outputs.connection-uri }}?sslmode=disable

```

### push

```{note}
Pushing a project is powered by [sqlc Cloud](https://dashboard.sqlc.dev). Sign up for [free](https://dashboard.sqlc.dev) today.
```

The following GitHub Workflow configuration runs [sqlc push](push.md) on
every push to `main`. Create an auth token via the
[dashboard](https://dashboard.sqlc.dev).

```yaml
name: sqlc
on: [push]
jobs:
  push:
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/main' }}
    steps:
    - uses: actions/checkout@v3
    - uses: sqlc-dev/setup-sqlc@v3
      with:
        sqlc-version: '1.28.0'
    - run: sqlc push
      env:
        SQLC_AUTH_TOKEN: ${{ secrets.SQLC_AUTH_TOKEN }}
```

### verify

```{note}
Verify database migrations is powered by [sqlc Cloud](https://dashboard.sqlc.dev). Sign up for [free](https://dashboard.sqlc.dev) today.
```

```yaml
name: sqlc
on: [push]
jobs:
  verify:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: sqlc-dev/setup-sqlc@v3
      with:
        sqlc-version: '1.28.0'
    - uses: sqlc-dev/action-setup-postgres@master
      with:
        postgres-version: "16"
      id: postgres
    - run: sqlc verify
      env:
        POSTGRESQL_SERVER_URI: ${{ steps.postgres.outputs.connection-uri }}?sslmode=disable
        SQLC_AUTH_TOKEN: ${{ secrets.SQLC_AUTH_TOKEN }}
  push:
    runs-on: ubuntu-latest
    if: ${{ github.ref == 'refs/heads/main' }}
    steps:
    - uses: sqlc-dev/setup-sqlc@v3
      with:
        sqlc-version: '1.28.0'
    - run: sqlc push
      env:
        SQLC_AUTH_TOKEN: ${{ secrets.SQLC_AUTH_TOKEN }}
``````

================
File: docs/howto/ddl.md
================
# Modifying the database schema

sqlc parses `CREATE TABLE` and `ALTER TABLE` statements in order to generate
the necessary code.

```sql
CREATE TABLE authors (
  id          SERIAL PRIMARY KEY,
  birth_year  int    NOT NULL
);

ALTER TABLE authors ADD COLUMN bio text NOT NULL;
ALTER TABLE authors DROP COLUMN birth_year;
ALTER TABLE authors RENAME TO writers;
```

```go
package db

type Writer struct {
	ID  int
	Bio string
}
```

## Handling SQL migrations

sqlc does not perform database migrations for you. However, sqlc is able to
differentiate between up and down migrations. sqlc ignores down migrations when
parsing SQL files.

sqlc supports parsing migrations from the following tools:

- [atlas](https://github.com/ariga/atlas)
- [dbmate](https://github.com/amacneil/dbmate)
- [golang-migrate](https://github.com/golang-migrate/migrate)
- [goose](https://github.com/pressly/goose)
- [sql-migrate](https://github.com/rubenv/sql-migrate)
- [tern](https://github.com/jackc/tern)

To enable migration parsing, specify the migration directory instead of a schema file:

```yaml
version: "2"
sql:
  - engine: "postgresql"
    queries: "query.sql"
    schema: "db/migrations"
    gen:
      go:
        package: "tutorial"
        out: "tutorial"
```

### atlas

```sql
-- Create "post" table
CREATE TABLE "public"."post" ("id" integer NOT NULL, "title" text NULL, "body" text NULL, PRIMARY KEY ("id"));
```

```go
package db

type Post struct {
	ID    int
	Title sql.NullString
	Body  sql.NullString
}
```

### dbmate

```sql
-- migrate:up
CREATE TABLE foo (bar INT NOT NULL);

-- migrate:down
DROP TABLE foo;
```

```go
package db

type Foo struct {
	Bar int32
}
```

### golang-migrate

**Warning:**
[golang-migrate interprets](https://github.com/golang-migrate/migrate/blob/master/MIGRATIONS.md#migration-filename-format)
migration filenames numerically. However, sqlc parses migration files in
lexicographic order. If you choose to have sqlc enumerate your migration files,
make sure their numeric ordering matches their lexicographic ordering to avoid
unexpected behavior. This can be done by prepending enough zeroes to the
migration filenames.

This doesn't work as intended.

```
1_initial.up.sql
...
9_foo.up.sql
# this migration file will be parsed BEFORE 9_foo
10_bar.up.sql
```

This worked as intended.

```
001_initial.up.sql
...
009_foo.up.sql
010_bar.up.sql
```

In `20060102.up.sql`:

```sql
CREATE TABLE post (
    id    int NOT NULL,
    title text,
    body  text,
    PRIMARY KEY(id)
);
```

In `20060102.down.sql`:

```sql
DROP TABLE post;
```

```go
package db

type Post struct {
	ID    int
	Title sql.NullString
	Body  sql.NullString
}
```

### goose

**Warning:**
sqlc parses migration files in lexicographic order. **If you are using numeric filenames for migrations in Goose and you choose to have sqlc enumerate your migration files**,
make sure their numeric ordering matches their lexicographic ordering to avoid
unexpected behavior. This can be done by prepending enough zeroes to the
migration filenames.

This doesn't work as intended.

```
1_initial.sql
...
9_foo.sql
# this migration file will be parsed BEFORE 9_foo
10_bar.sql
```

This worked as intended.

```
001_initial.sql
...
009_foo.sql
010_bar.sql
```

```sql
-- +goose Up
CREATE TABLE post (
    id    int NOT NULL,
    title text,
    body  text,
    PRIMARY KEY(id)
);

-- +goose Down
DROP TABLE post;
```

```go
package db

type Post struct {
	ID    int
	Title sql.NullString
	Body  sql.NullString
}
```

### sql-migrate

```sql
-- +migrate Up
-- SQL in section 'Up' is executed when this migration is applied
CREATE TABLE people (id int);


-- +migrate Down
-- SQL section 'Down' is executed when this migration is rolled back
DROP TABLE people;
```

```go
package db

type People struct {
	ID int32
}
```

### tern

```sql
CREATE TABLE comment (id int NOT NULL, text text NOT NULL);
---- create above / drop below ----
DROP TABLE comment;
```

```go
package db

type Comment struct {
	ID   int32
	Text string
}
```

================
File: docs/howto/delete.md
================
# Deleting rows

```sql
CREATE TABLE authors (
  id         SERIAL PRIMARY KEY,
  bio        text   NOT NULL
);

-- name: DeleteAuthor :exec
DELETE FROM authors WHERE id = $1;
```

```go
package db

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

const deleteAuthor = `-- name: DeleteAuthor :exec
DELETE FROM authors WHERE id = $1
`

func (q *Queries) DeleteAuthor(ctx context.Context, id int) error {
	_, err := q.db.ExecContext(ctx, deleteAuthor, id)
	return err
}
```

================
File: docs/howto/embedding.md
================
#### Embedding structs

Embedding allows you to reuse existing model structs in more queries, resulting
in less manual serialization work. First, imagine we have the following schema
with students and test scores.

```sql
CREATE TABLE students (
  id   bigserial PRIMARY KEY,
  name text NOT NULL,
  age  integer NOT NULL
);

CREATE TABLE test_scores (
  student_id bigint NOT NULL,
  score      integer NOT NULL,
  grade      text NOT NULL
);
```

We want to select the student record and the scores they got on a test.
Here's how we'd usually do that:

```sql
-- name: ScoreAndTests :many
SELECT students.*, test_scores.*
FROM students
JOIN test_scores ON test_scores.student_id = students.id
WHERE students.id = $1;
```

When using Go, sqlc will produce a struct like this:

```go
type ScoreAndTestsRow struct {
	ID        int64
	Name      string
	Age       int32
	StudentID int64
	Score     int32
	Grade     string
}
```

With embedding, the struct will contain a model for both tables instead of a
flattened list of columns.

```sql
-- name: ScoreAndTests :many
SELECT sqlc.embed(students), sqlc.embed(test_scores)
FROM students
JOIN test_scores ON test_scores.student_id = students.id
WHERE students.id = $1;
```

```
type ScoreAndTestsRow struct {
	Student   Student
	TestScore TestScore
}
```

================
File: docs/howto/generate.md
================
# `generate` - Generating code

`sqlc generate` parses SQL, analyzes the results, and outputs code. Your schema and queries are stored in separate SQL files. The paths to these files live in a `sqlc.yaml` configuration file.

```yaml
version: "2"
sql:
  - engine: "postgresql"
    queries: "query.sql"
    schema: "schema.sql"
    gen:
      go:
        package: "tutorial"
        out: "tutorial"
        sql_package: "pgx/v5"
```

We've written extensive docs on [retrieving](select.md), [inserting](insert.md),
[updating](update.md), and [deleting](delete.md) rows. 

By default, sqlc runs its analysis using a built-in query analysis engine. While fast, this engine can't handle some complex queries and type-inference.

You can configure sqlc to use a database connection for enhanced analysis using metadata from that database.

The database-backed analyzer currently supports PostgreSQL, with [MySQL](https://github.com/sqlc-dev/sqlc/issues/2902) and [SQLite](https://github.com/sqlc-dev/sqlc/issues/2903)
support planned in the future.

## Enhanced analysis with managed databases

With [managed databases](managed-databases.md) configured, `generate` will automatically create a hosted ephemeral database with your
schema and use that database to improve its query analysis. And sqlc will cache its analysis locally
on a per-query basis to speed up future `generate` runs. This saves you the trouble of running and maintaining a database with
an up-to-date schema. Here's a minimal working configuration:

```yaml
version: "2"
servers:
- engine: postgresql
  uri: "postgres://locahost:5432/postgres?sslmode=disable"
sql:
  - engine: "postgresql"
    queries: "query.sql"
    schema: "schema.sql"
    database:
      managed: true
    gen:
      go:
        out: "db"
        sql_package: "pgx/v5"
```

## Enhanced analysis using your own database

You can opt-in to database-backed analysis using your own database, by providing a `uri` in your sqlc
[database](../reference/config.md#database) configuration.

The `uri` string can contain references to environment variables using the `${...}`
syntax. In the following example, the connection string will have the value of
the `PG_PASSWORD` environment variable set as its password.

```yaml
version: "2"
sql:
  - engine: "postgresql"
    queries: "query.sql"
    schema: "schema.sql"
    database:
      uri: "postgres://postgres:${PG_PASSWORD}@localhost:5432/postgres"
    gen:
      go:
        out: "db"
        sql_package: "pgx/v5"
```

Databases configured with a `uri` must have an up-to-date schema for query analysis to work correctly, and `sqlc` does not apply schema migrations your database. Use your migration tool of choice to create the necessary
tables and objects before running `sqlc generate`.

================
File: docs/howto/insert.md
================
# Inserting rows

```sql
CREATE TABLE authors (
  id         SERIAL PRIMARY KEY,
  bio        text   NOT NULL
);

-- name: CreateAuthor :exec
INSERT INTO authors (bio) VALUES ($1);
```

```go
package db

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

const createAuthor = `-- name: CreateAuthor :exec
INSERT INTO authors (bio) VALUES ($1)
`

func (q *Queries) CreateAuthor(ctx context.Context, bio string) error {
	_, err := q.db.ExecContext(ctx, createAuthor, bio)
	return err
}
```

## Returning columns from inserted rows

sqlc has full support for the `RETURNING` statement.

```sql
-- Example queries for sqlc
CREATE TABLE authors (
  id   BIGSERIAL PRIMARY KEY,
  name text      NOT NULL,
  bio  text
);

-- name: CreateAuthor :one
INSERT INTO authors (
  name, bio
) VALUES (
  $1, $2
)
RETURNING *;

-- name: CreateAuthorAndReturnId :one
INSERT INTO authors (
  name, bio
) VALUES (
  $1, $2
)
RETURNING id;
```

```go
package db

import (
	"context"
	"database/sql"
)

const createAuthor = `-- name: CreateAuthor :one
INSERT INTO authors (
  name, bio
) VALUES (
  $1, $2
)
RETURNING id, name, bio
`

type CreateAuthorParams struct {
	Name string
	Bio  sql.NullString
}

func (q *Queries) CreateAuthor(ctx context.Context, arg CreateAuthorParams) (Author, error) {
	row := q.db.QueryRowContext(ctx, createAuthor, arg.Name, arg.Bio)
	var i Author
	err := row.Scan(&i.ID, &i.Name, &i.Bio)
	return i, err
}

const createAuthorAndReturnId = `-- name: CreateAuthorAndReturnId :one
INSERT INTO authors (
  name, bio
) VALUES (
  $1, $2
)
RETURNING id
`

type CreateAuthorAndReturnIdParams struct {
	Name string
	Bio  sql.NullString
}

func (q *Queries) CreateAuthorAndReturnId(ctx context.Context, arg CreateAuthorAndReturnIdParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createAuthorAndReturnId, arg.Name, arg.Bio)
	var id int64
	err := row.Scan(&id)
	return id, err
}
```

## Using CopyFrom

### PostgreSQL

PostgreSQL supports the [COPY protocol](https://www.postgresql.org/docs/current/sql-copy.html) that can insert rows a lot faster than sequential inserts. You can use this easily with sqlc:

```sql
CREATE TABLE authors (
  id         SERIAL PRIMARY KEY,
  name       text   NOT NULL,
  bio        text   NOT NULL
);

-- name: CreateAuthors :copyfrom
INSERT INTO authors (name, bio) VALUES ($1, $2);
```

```go
type CreateAuthorsParams struct {
	Name string
	Bio  string
}

func (q *Queries) CreateAuthors(ctx context.Context, arg []CreateAuthorsParams) (int64, error) {
	...
}
```

The `:copyfrom` command requires either `pgx/v4` or `pgx/v5`.

```yaml
version: "2"
sql:
  - engine: "postgresql"
    queries: "query.sql"
    schema: "query.sql"
    gen:
      go:
        package: "db"
        sql_package: "pgx/v5"
        out: "db"
```

### MySQL

MySQL supports a similar feature using [LOAD DATA](https://dev.mysql.com/doc/refman/8.0/en/load-data.html).

Errors and duplicate keys are treated as warnings and insertion will
continue, even without an error for some cases. Use this in a transaction
and use SHOW WARNINGS to check for any problems and roll back if necessary.

Check the [error handling](https://dev.mysql.com/doc/refman/8.0/en/load-data.html#load-data-error-handling) documentation for more information.

```sql
CREATE TABLE foo (a text, b integer, c DATETIME, d DATE);

-- name: InsertValues :copyfrom
INSERT INTO foo (a, b, c, d) VALUES (?, ?, ?, ?);
```

```go
func (q *Queries) InsertValues(ctx context.Context, arg []InsertValuesParams) (int64, error) {
	...
}
```

The `:copyfrom` command requires setting the `sql_package` and `sql_driver` options.

```yaml
version: "2"
sql:
  - engine: "mysql"
    queries: "query.sql"
    schema: "query.sql"
    gen:
      go:
        package: "db"
        sql_package: "database/sql"
        sql_driver: "github.com/go-sql-driver/mysql"
        out: "db"
```

================
File: docs/howto/managed-databases.md
================
# Managed databases

*Added in v1.22.0*

`sqlc` can automatically create read-only databases to power query analysis,
linting and verification. These databases are immediately useful for powering
sqlc's database-connected query analyzer, an opt-in feature that improves upon
sqlc's built-in query analysis engine. PostgreSQL support is available today,
with MySQL on the way.

Once configured, `sqlc` will also use managed databases when linting queries
with [`sqlc vet`](vet.md) in cases where your lint rules require a connection
to a running database.

Managed databases are under active development, and we're interested in
supporting other use-cases.

## Configuring managed databases

To configure `sqlc` to use managed databases, remove the `uri` key from your
`database` configuration and replace it with the `managed` key set to `true`.
Access to a running database server is required. Add a connection string to the `servers` mapping.

```yaml
version: '2'
servers:
- engine: postgresql
  uri: "postgres://locahost:5432/postgres?sslmode=disable"
sql:
- schema: schema.sql
  queries: query.sql
  engine: postgresql
  database:
    managed: true
```

An environment variable can also be used via the `${}` syntax.

```yaml
version: '2'
servers:
- engine: postgresql
  uri: ${DATABASE_URI}
sql:
- schema: schema.sql
  queries: query.sql
  engine: postgresql
  database:
    managed: true
```

## Improving codegen

Without a database connection, sqlc does its best to parse, analyze and compile your queries just using
the schema you pass it and what it knows about the various database engines it supports. In many cases
this works just fine, but for more advanced queries sqlc might not have enough information to produce good code.

With managed databases configured, `sqlc generate` will automatically create a hosted ephemeral database with your
schema and use that database to improve its query analysis. And sqlc will cache its analysis locally
on a per-query basis to speed up future codegen runs. Here's a minimal working configuration:

```yaml
version: '2'
servers:
- engine: postgresql
  uri: "postgres://locahost:5432/postgres?sslmode=disable"
sql:
- schema: schema.sql
  queries: query.sql
  engine: postgresql
  database:
    managed: true
  gen:
    go:
      out: "db"
```

## Linting queries

With managed databases configured, `sqlc vet` will automatically create a hosted ephemeral database with your
schema and use that database when running lint rules that require a
database connection, e.g. any [rule relying on `EXPLAIN ...` output](vet.md#rules-using-explain-output).

If you don't yet have any vet rules, the [built-in sqlc/db-prepare rule](vet.md#sqlc-db-prepare)
is a good place to start. It prepares each of your queries against the database
to ensure the query is valid. Here's a minimal working configuration:

```yaml
version: '2'
servers:
- engine: postgresql
  uri: "postgres://locahost:5432/postgres?sslmode=disable"
sql:
- schema: schema.sql
  queries: query.sql
  engine: postgresql
  database:
    managed: true
  rules:
  - sqlc/db-prepare
```

================
File: docs/howto/named_parameters.md
================
# Naming parameters

sqlc tries to generate good names for positional parameters, but sometimes it
lacks enough context. The following SQL generates parameters with less than
ideal names:

```sql
-- name: UpsertAuthorName :one
UPDATE author
SET
  name = CASE WHEN $1::bool
    THEN $2::text
    ELSE name
    END
RETURNING *;
```

```go
type UpdateAuthorNameParams struct {
	Column1   bool   `json:""`
	Column2_2 string `json:"_2"`
}
```

In these cases, named parameters give you the control over field names on the
Params struct.

```sql
-- name: UpsertAuthorName :one
UPDATE author
SET
  name = CASE WHEN sqlc.arg(set_name)::bool
    THEN sqlc.arg(name)::text
    ELSE name
    END
RETURNING *;
```

```go
type UpdateAuthorNameParams struct {
	SetName bool   `json:"set_name"`
	Name    string `json:"name"`
}
```

If the `sqlc.arg()` syntax is too verbose for your taste, you can use the `@`
operator as a shortcut.

```{note}
The `@` operator as a shortcut for `sqlc.arg()` is not supported in MySQL.
```

```sql
-- name: UpsertAuthorName :one
UPDATE author
SET
  name = CASE WHEN @set_name::bool
    THEN @name::text
    ELSE name
    END
RETURNING *;
```

## Nullable parameters

sqlc infers the nullability of any specified parameters, and often does exactly
what you want. If you want finer control over the nullability of your
parameters, you may use `sqlc.narg()` (**n**ullable arg) to override the default
behavior. Using `sqlc.narg` tells sqlc to ignore whatever nullability it has
inferred and generate a nullable parameter instead. There is no nullable
equivalent of the `@` syntax.

Here is an example that uses a single query to allow updating an author's
name, bio or both.

```sql
-- name: UpdateAuthor :one
UPDATE author
SET
 name = coalesce(sqlc.narg('name'), name),
 bio = coalesce(sqlc.narg('bio'), bio)
WHERE id = sqlc.arg('id')
RETURNING *;
```

The following code is generated:

```go
type UpdateAuthorParams struct {
	Name sql.NullString
	Bio  sql.NullString
	ID   int64
}
```

================
File: docs/howto/overrides.md
================
# Overriding types

In many cases it's useful to tell `sqlc` explicitly what Go type you want it to
use for a query input or output. For instance, a PostgreSQL UUID type will map
to `UUID` from `github.com/jackc/pgx/pgtype` by default when you use
`pgx/v5`, but you may want `sqlc` to use `UUID` from `github.com/google/uuid`
instead.

If you'd like `sqlc` to use a different Go type, specify the package import
path and type in the `overrides` list.

```yaml
version: "2"
sql:
- schema: "postgresql/schema.sql"
  queries: "postgresql/query.sql"
  engine: "postgresql"
  gen:
    go: 
      package: "authors"
      out: "db"
      sql_package: "pgx/v5"
      overrides:
        - db_type: "uuid"
          go_type:
            import: "github.com/google/uuid"
            type: "UUID"
```

## The `overrides` list

Each element in the `overrides` list has the following keys:

- `db_type`:
  - A database type to override. Find the full list of supported types in [postgresql_type.go](https://github.com/sqlc-dev/sqlc/blob/main/internal/codegen/golang/postgresql_type.go#L12) or [mysql_type.go](https://github.com/sqlc-dev/sqlc/blob/main/internal/codegen/golang/mysql_type.go#L12). Note that for Postgres you must use pg_catalog-prefixed names where available. `db_type` and `column` are mutually exclusive.
- `column`:
  - A column name to override. The value should be of the form `table.column` but you can also specify `schema.table.column` or `catalog.schema.table.column`. `column` and `db_type` are mutually exclusive.
- `go_type`:
  - The fully-qualified name of a Go type to use in generated code. This is usually a string but can also be [a map](#the-go-type-map) for more complex configurations.
- `go_struct_tag`:
  - A reflect-style struct tag to use in generated code, e.g. `a:"b" x:"y,z"`.
    If you want `json` or `db` tags for all fields, use `emit_json_tags` or `emit_db_tags` instead.
- `unsigned`:
  - If `true`, sqlc will apply this override when a numeric db_type is unsigned.
    Note that this has no effect on `column` overrides. Defaults to `false`.
- `nullable`:
  - If `true`, sqlc will apply this override when a column is nullable.
    Otherwise `sqlc` will apply this override when a column is non-nullable.
    Note that this has no effect on `column` overrides. Defaults to `false`.

Note that a single `db_type` override configuration applies to either nullable or non-nullable
columns, but not both. If you want the same Go type to override in both cases, you'll
need to configure two overrides.

When generating code, entries using the `column` key will always take precedence over
entries using the `db_type` key.

### The `go_type` map

Some overrides may require more detailed configuration. If necessary, `go_type`
can be a map with the following keys:

- `import`:
  - The import path for the package where the type is defined.
- `package`:
  - The package name where the type is defined. This should only be necessary when your import path doesn't end with the desired package name.
- `type`:
  - The type name itself, without any package prefix.
- `pointer`:
  - If `true`, generated code will use a pointer to the type rather than the type itself.
- `slice`:
  - If `true`, generated code will use a slice of the type rather than the type itself.

An example:

```yaml
version: "2"
sql:
- schema: "postgresql/schema.sql"
  queries: "postgresql/query.sql"
  engine: "postgresql"
  gen:
    go: 
      package: "authors"
      out: "db"
      sql_package: "pgx/v5"
      overrides:
        - db_type: "uuid"
          go_type:
            import: "a/b/v2"
            package: "b"
            type: "MyType"
            pointer: true
```

================
File: docs/howto/prepared_query.md
================
# Preparing queries

If you're using `pgx/v5` you get its
[implicit support](https://github.com/jackc/pgx/wiki/Automatic-Prepared-Statement-Caching)
for prepared statements. No additional `sqlc` configuration is required.

For other drivers, `sqlc` can give you the option to explicitly use prepared
queries. These prepared queries also work with transactions.

You'll need to set `emit_prepared_queries` to `true` in your `sqlc` configuration
to generate code similar to the example below.

```sql
CREATE TABLE records (
  id SERIAL PRIMARY KEY
);

-- name: GetRecord :one
SELECT * FROM records
WHERE id = $1;
```

```go
package db

import (
	"context"
	"database/sql"
	"fmt"
)

type Record struct {
	ID int32
}

type DBTX interface {
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

func Prepare(ctx context.Context, db DBTX) (*Queries, error) {
	q := Queries{db: db}
	var err error
	if q.getRecordStmt, err = db.PrepareContext(ctx, getRecord); err != nil {
		return nil, fmt.Errorf("error preparing query GetRecord: %w", err)
	}
	return &q, nil
}

func (q *Queries) queryRow(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) *sql.Row {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryRowContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryRowContext(ctx, args...)
	default:
		return q.db.QueryRowContext(ctx, query, args...)
	}
}

type Queries struct {
	db            DBTX
	tx            *sql.Tx
	getRecordStmt *sql.Stmt
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db:            tx,
		tx:            tx,
		getRecordStmt: q.getRecordStmt,
	}
}

const getRecord = `-- name: GetRecord :one
SELECT id FROM records
WHERE id = $1
`

func (q *Queries) GetRecord(ctx context.Context, id int32) (int32, error) {
	row := q.queryRow(ctx, q.getRecordStmt, getRecord, id)
	err := row.Scan(&id)
	return id, err
}
```

================
File: docs/howto/push.md
================
# `push` - Uploading projects

```{note}
`push` is powered by [sqlc Cloud](https://dashboard.sqlc.dev). Sign up for [free](https://dashboard.sqlc.dev) today.
```

*Added in v1.24.0*

We've renamed the `upload` sub-command to `push`. We've also changed the data sent along in a push request. Upload used to include the configuration file, migrations, queries, and all generated code. Push drops the generated code in favor of including the [plugin.GenerateRequest](https://buf.build/sqlc/sqlc/docs/main:plugin#plugin.GenerateRequest), which is the protocol buffer message we pass to codegen plugins.

## Add configuration

After creating a project, add the project ID to your sqlc configuration file.

```yaml
version: "2"
cloud:
  project: "<PROJECT_ID>"
```

You'll also need to create an auth token and make it available via the
`SQLC_AUTH_TOKEN` environment variable.

```shell
export SQLC_AUTH_TOKEN=sqlc_xxxxxxxx
```

## Dry run

You can see what's included when uploading your project by using using the
`--dry-run` flag:

```shell
$ sqlc push --dry-run
2023/11/21 10:39:51 INFO config file=sqlc.yaml bytes=912
2023/11/21 10:39:51 INFO codegen_request queryset=app file=codegen_request.pb
2023/11/21 10:39:51 INFO schema queryset=app file=migrations/00001_initial.sql bytes=3033
2023/11/21 10:39:51 INFO query queryset=app file=queries/app.sql bytes=1150
```

The output is the files `sqlc` would have sent without the `--dry-run` flag.

## Push

Once you're ready to push, remove the `--dry-run` flag.

```shell
$ sqlc push
```

### Tags

You can provide tags to associate with a push, primarily as a convenient reference when using `sqlc verify` with the `against` argument.

Tags only refer to a single push, so if you pass an existing tag to `push` it will overwrite the previous reference.

```shell
$ sqlc push --tag main
```

### Annotations 

Annotations are added to each push request. By default, we include these environment variables (if they are present).

```
GITHUB_REPOSITORY
GITHUB_REF
GITHUB_REF_NAME
GITHUB_REF_TYPE
GITHUB_SHA
```

================
File: docs/howto/query_count.md
================
# Counting rows

```sql
CREATE TABLE authors (
  id       SERIAL PRIMARY KEY,
  hometown text   NOT NULL
);

-- name: CountAuthors :one
SELECT count(*) FROM authors;

-- name: CountAuthorsByTown :many
SELECT hometown, count(*) FROM authors
GROUP BY 1
ORDER BY 1;
```

```go
package db

import (
	"context"
	"database/sql"
)

type DBTX interface {
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

const countAuthors = `-- name: CountAuthors :one
SELECT count(*) FROM authors
`

func (q *Queries) CountAuthors(ctx context.Context) (int, error) {
	row := q.db.QueryRowContext(ctx, countAuthors)
	var i int
	err := row.Scan(&i)
	return i, err
}

const countAuthorsByTown = `-- name: CountAuthorsByTown :many
SELECT hometown, count(*) FROM authors
GROUP BY 1
ORDER BY 1
`

type CountAuthorsByTownRow struct {
	Hometown string
	Count    int
}

func (q *Queries) CountAuthorsByTown(ctx context.Context) ([]CountAuthorsByTownRow, error) {
	rows, err := q.db.QueryContext(ctx, countAuthorsByTown)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountAuthorsByTownRow{}
	for rows.Next() {
		var i CountAuthorsByTownRow
		if err := rows.Scan(&i.Hometown, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
```

================
File: docs/howto/rename.md
================
# Renaming fields

Struct field names are generated from column names using a simple algorithm:
split the column name on underscores and capitalize the first letter of each
part.

```
account     -> Account
spotify_url -> SpotifyUrl
app_id      -> AppID
```

If you're not happy with a field's generated name, use the `rename` mapping
to pick a new name. The keys are column names and the values are the struct
field name to use.

```yaml
version: "2"
sql:
- schema: "postgresql/schema.sql"
  queries: "postgresql/query.sql"
  engine: "postgresql"
  gen:
    go: 
      package: "authors"
      out: "postgresql"
      rename:
        spotify_url: "SpotifyURL"
```

## Tables

The output structs associated with tables can also be renamed. By default, the struct name will be the singular version of the table name. For example, the `authors` table will generate an `Author` struct.

```sql
CREATE TABLE authors (
  id   BIGSERIAL PRIMARY KEY,
  name text      NOT NULL,
  bio  text
);
```

```go
package db

import (
	"database/sql"
)

type Author struct {
	ID   int64
	Name string
	Bio  sql.NullString
}
```

To rename this struct, you must use the generated struct name. In this example, that would be `author`. Use the `rename` map to change the name of this struct to `Writer` (note the uppercase `W`).

```yaml
version: '1'
packages:
- path: db
  engine: postgresql
  schema: query.sql
  queries: query.sql
rename:
  author: Writer
```

```yaml
version: "2"
sql:
  - engine: postgresql
    queries: query.sql
    schema: query.sql
overrides:
  go:
    rename:
      author: Writer
```

```go
package db

import (
	"database/sql"
)

type Writer struct {
	ID   int64
	Name string
	Bio  sql.NullString
}
```

## Limitations

Rename mappings apply to an entire package. Therefore, a column named `foo` and
a table name `foo` can't map to different rename values.

================
File: docs/howto/select.md
================
# Retrieving rows

To generate a database access method, annotate a query with a specific comment.

```sql
CREATE TABLE authors (
  id         SERIAL PRIMARY KEY,
  bio        text   NOT NULL,
  birth_year int    NOT NULL
);


-- name: GetAuthor :one
SELECT * FROM authors
WHERE id = $1;

-- name: ListAuthors :many
SELECT * FROM authors
ORDER BY id;
```

A few new pieces of code are generated beyond the `Author` struct. An interface
for the underlying database is generated. The `*sql.DB` and `*sql.Tx` types
satisfy this interface.

The database access methods are added to a `Queries` struct, which is created
using the `New` method.

Note that the `*` in our query has been replaced with explicit column names.
This change ensures that the query will never return unexpected data.

Our query was annotated with `:one`, meaning that it should only return a
single row. We scan the data from that one into a `Author` struct.

Since the get query has a single parameter, the `GetAuthor` method takes a single
`int` as an argument.

Since the list query has no parameters, the `ListAuthors` method accepts no
arguments.


```go
package db

import (
	"context"
	"database/sql"
)

type Author struct {
	ID        int
	Bio       string
	BirthYear int
}

type DBTX interface {
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

const getAuthor = `-- name: GetAuthor :one
SELECT id, bio, birth_year FROM authors
WHERE id = $1
`

func (q *Queries) GetAuthor(ctx context.Context, id int) (Author, error) {
	row := q.db.QueryRowContext(ctx, getAuthor, id)
	var i Author
	err := row.Scan(&i.ID, &i.Bio, &i.BirthYear)
	return i, err
}

const listAuthors = `-- name: ListAuthors :many
SELECT id, bio, birth_year FROM authors
ORDER BY id
`

func (q *Queries) ListAuthors(ctx context.Context) ([]Author, error) {
	rows, err := q.db.QueryContext(ctx, listAuthors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Author
	for rows.Next() {
		var i Author
		if err := rows.Scan(&i.ID, &i.Bio, &i.BirthYear); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
```

## Selecting columns

```sql
CREATE TABLE authors (
  id         SERIAL PRIMARY KEY,
  bio        text   NOT NULL,
  birth_year int    NOT NULL
);

-- name: GetBioForAuthor :one
SELECT bio FROM authors
WHERE id = $1;

-- name: GetInfoForAuthor :one
SELECT bio, birth_year FROM authors
WHERE id = $1;
```

When selecting a single column, only that value is returned. The `GetBioForAuthor`
method takes a single `int` as an argument and returns a `string` and an
`error`.

When selecting multiple columns, a row record (method-specific struct) is
returned. In this case, `GetInfoForAuthor` returns a struct with two fields:
`Bio` and `BirthYear`.

If a query result has no row records, a zero value and an `ErrNoRows` error are
returned instead of a zero value and `nil`. For instance, when the `GetBioForAuthor`
result has no rows, it will return `""` and `ErrNoRows`.

```go
package db

import (
	"context"
	"database/sql"
)

type DBTX interface {
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

const getBioForAuthor = `-- name: GetBioForAuthor :one
SELECT bio FROM authors
WHERE id = $1
`

func (q *Queries) GetBioForAuthor(ctx context.Context, id int) (string, error) {
	row := q.db.QueryRowContext(ctx, getBioForAuthor, id)
	var i string
	err := row.Scan(&i)
	return i, err
}

const getInfoForAuthor = `-- name: GetInfoForAuthor :one
SELECT bio, birth_year FROM authors
WHERE id = $1
`

type GetInfoForAuthorRow struct {
	Bio       string
	BirthYear int
}

func (q *Queries) GetInfoForAuthor(ctx context.Context, id int) (GetInfoForAuthorRow, error) {
	row := q.db.QueryRowContext(ctx, getInfoForAuthor, id)
	var i GetInfoForAuthorRow
	err := row.Scan(&i.Bio, &i.BirthYear)
	return i, err
}
```

## Passing a slice as a parameter to a query

### PostgreSQL

In PostgreSQL,
[ANY](https://www.postgresql.org/docs/current/functions-comparisons.html#id-1.5.8.28.16)
allows you to check if a value exists in an array expression. Queries using ANY
with a single parameter will generate method signatures with slices as
arguments. Use the postgres data types, eg: int, varchar, etc.

```sql
CREATE TABLE authors (
  id         SERIAL PRIMARY KEY,
  bio        text   NOT NULL,
  birth_year int    NOT NULL
);

-- name: ListAuthorsByIDs :many
SELECT * FROM authors
WHERE id = ANY($1::int[]);
```

The above SQL will generate the following code:

```go
package db

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

type Author struct {
	ID        int
	Bio       string
	BirthYear int
}

type DBTX interface {
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

const listAuthors = `-- name: ListAuthorsByIDs :many
SELECT id, bio, birth_year FROM authors
WHERE id = ANY($1::int[])
`

func (q *Queries) ListAuthorsByIDs(ctx context.Context, ids []int) ([]Author, error) {
	rows, err := q.db.QueryContext(ctx, listAuthors, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Author
	for rows.Next() {
		var i Author
		if err := rows.Scan(&i.ID, &i.Bio, &i.BirthYear); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
```

### MySQL and SQLite

MySQL and SQLite differ from PostgreSQL in that placeholders must be generated based on
the number of elements in the slice you pass in. Though trivial it is still
something of a nuisance. The passed in slice must not be nil or empty or an
error will be returned (ie not a panic). The placeholder insertion location is
marked by the meta-function `sqlc.slice()` (which is similar to `sqlc.arg()`
that you see documented under [Naming parameters](named_parameters.md)).

To rephrase, the `sqlc.slice('param')` behaves identically to `sqlc.arg()` it
terms of how it maps the explicit argument to the function signature, eg:

  * `sqlc.slice('ids')` maps to `ids []GoType` in the function signature
  * `sqlc.slice(cust_ids)` maps to `custIds []GoType` in the function signature
    (like `sqlc.arg()`, the parameter does not have to be quoted)

This feature is not compatible with `emit_prepared_queries` statement found in the
[Configuration file](../reference/config.md).

```sql
CREATE TABLE authors (
  id         SERIAL PRIMARY KEY,
  bio        text   NOT NULL,
  birth_year int    NOT NULL
);

-- name: ListAuthorsByIDs :many
SELECT * FROM authors
WHERE id IN (sqlc.slice('ids'));
```

The above SQL will generate the following code:

```go
package db

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
)

type Author struct {
	ID        int
	Bio       string
	BirthYear int
}

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}

const listAuthorsByIDs = `-- name: ListAuthorsByIDs :many
SELECT id, bio, birth_year FROM authors
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) ListAuthorsByIDs(ctx context.Context, ids []int64) ([]Author, error) {
	sql := listAuthorsByIDs
	var queryParams []interface{}
	if len(ids) == 0 {
		return nil, fmt.Errorf("slice ids must have at least one element")
	}
	for _, v := range ids {
		queryParams = append(queryParams, v)
	}
	sql = strings.Replace(sql, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	rows, err := q.db.QueryContext(ctx, sql, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Author
	for rows.Next() {
		var i Author
		if err := rows.Scan(&i.ID, &i.Bio, &i.BirthYear); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
```

================
File: docs/howto/structs.md
================
# Configuring generated structs

## Naming scheme

Structs generated from tables will attempt to use the singular form of a table
name if the table name is pluralized.

```sql
CREATE TABLE authors (
  id   SERIAL PRIMARY KEY,
  name text   NOT NULL
);
```

```go
package db

// Struct names use the singular form of table names
type Author struct {
	ID   int
	Name string
}
```

## JSON tags

```sql
CREATE TABLE authors (
  id         SERIAL    PRIMARY KEY,
  created_at timestamp NOT NULL
);
```

sqlc can generate structs with JSON tags by adding the `emit_json_tags` key to the configuration file as it shows on [configuration reference](../reference/config.md).
The JSON name for a field matches
the column name in the database.

```go
package db

import (
	"time"
)

type Author struct {
	ID        int       `json:"id"`
	CreatedAt time.Time `json:"created_at"`
}
```

## More control

See the guide to [Overriding types](./overrides.md) for fine-grained control over struct field types and tags.

================
File: docs/howto/transactions.md
================
# Using transactions
In the code generated by sqlc, the `WithTx` method allows a `Queries` instance to be associated with a transaction.

For example, with the following SQL structure:

`schema.sql`:
```sql
CREATE TABLE records (
  id SERIAL PRIMARY KEY,
  counter INT NOT NULL
);
```

`query.sql`
```sql
-- name: GetRecord :one
SELECT * FROM records
WHERE id = $1;

-- name: UpdateRecord :exec
UPDATE records SET counter = $2
WHERE id = $1;
```

And the generated code from sqlc in `db.go`:
```go
package tutorial

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}

```

You'd use it like this:

```go
// Using `github/lib/pq` as the driver.
func bumpCounter(ctx context.Context, db *sql.DB, queries *tutorial.Queries, id int32) error {
	tx, err := db.Begin()
	if err != nil {
		return err
	}
	defer tx.Rollback()
	qtx := queries.WithTx(tx)
	r, err := qtx.GetRecord(ctx, id)
	if err != nil {
		return err
	}
	if err := qtx.UpdateRecord(ctx, tutorial.UpdateRecordParams{
		ID:      r.ID,
		Counter: r.Counter + 1,
	}); err != nil {
		return err
	}
	return tx.Commit()
}

// Using `github.com/jackc/pgx/v5` as the driver.
func bumpCounter(ctx context.Context, db *pgx.Conn, queries *tutorial.Queries, id int32) error {
	tx, err := db.Begin(ctx)
	if err != nil {
		return err
	}
	defer tx.Rollback(ctx)
	qtx := queries.WithTx(tx)
	r, err := qtx.GetRecord(ctx, id)
	if err != nil {
		return err
	}
	if err := qtx.UpdateRecord(ctx, tutorial.UpdateRecordParams{
		ID:      r.ID,
		Counter: r.Counter + 1,
	}); err != nil {
		return err
	}
	return tx.Commit(ctx)
}
```

================
File: docs/howto/update.md
================
# Updating rows

```sql
CREATE TABLE authors (
  id         SERIAL PRIMARY KEY,
  bio        text   NOT NULL
);
```

## Single parameter

If your query has a single parameter, your Go method will also have a single
parameter.

```sql
-- name: UpdateAuthorBios :exec
UPDATE authors SET bio = $1;
```

```go
package db

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

const updateAuthorBios = `-- name: UpdateAuthorBios :exec
UPDATE authors SET bio = $1
`

func (q *Queries) UpdateAuthorBios(ctx context.Context, bio string) error {
	_, err := q.db.ExecContext(ctx, updateAuthorBios, bio)
	return err
}
```

## Multiple parameters

If your query has more than one parameter, your Go method will accept a
`Params` struct.

```sql
-- name: UpdateAuthor :exec
UPDATE authors SET bio = $2
WHERE id = $1;
```

```go
package db

import (
	"context"
	"database/sql"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

const updateAuthor = `-- name: UpdateAuthor :exec
UPDATE authors SET bio = $2
WHERE id = $1
`

type UpdateAuthorParams struct {
	ID  int32
	Bio string
}

func (q *Queries) UpdateAuthor(ctx context.Context, arg UpdateAuthorParams) error {
	_, err := q.db.ExecContext(ctx, updateAuthor, arg.ID, arg.Bio)
	return err
}
```

================
File: docs/howto/verify.md
================
# `verify` - Verifying schema changes

*Added in v1.24.0*

Schema updates and poorly-written queries often bring down production databases. That’s bad.

Out of the box, `sqlc generate` catches some of these issues. Running `sqlc vet` with the `sqlc/db-prepare` rule catches more subtle problems. But there is a large class of issues that sqlc can’t prevent by looking at current schema and queries alone.

For instance, when a schema change is proposed, existing queries and code running in production might fail when the schema change is applied. Enter `sqlc verify`, which analyzes existing queries against new schema changes and errors if there are any issues.

Let's look at an example. Assume you have these two tables in production.

```sql
CREATE TABLE users (
  id UUID PRIMARY KEY
);

CREATE TABLE user_actions (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL,
  action TEXT,
  created_at TIMESTAMP
);
```

Your application contains the following query to join user actions against the users table.

```sql
-- name: GetUserActions :many
SELECT * FROM users u
JOIN user_actions ua ON u.id = ua.user_id
ORDER BY created_at;
```

So far, so good. Then assume you propose this schema change:

```sql
ALTER TABLE users ADD COLUMN created_at TIMESTAMP;
```

Running `sqlc generate` fails with this change, returning a `column reference "created_at" is ambiguous` error. You update your query to fix the issue.

```sql
-- name: GetUserActions :many
SELECT * FROM users u
JOIN user_actions ua ON u.id = ua.user_id
ORDER BY u.created_at;
```

While that change fixes the issue, there's a production outage waiting to happen. When the schema change is applied, the existing `GetUserActions` query will begin to fail. The correct way to fix this is to deploy the updated query before applying the schema migration.

It ensures migrations are safe to deploy by sending your current schema and queries to sqlc cloud. There, we run the queries for your latest push against your new schema changes. This check catches backwards incompatible schema changes for existing queries.

Here `sqlc verify` alerts you to the fact that ORDER BY "created_at" is ambiguous.

```sh
$ sqlc verify
FAIL: app query.sql

=== Failed
=== FAIL: app query.sql GetUserActions
    ERROR: column reference "created_at" is ambiguous (SQLSTATE 42702)
```

By the way, this scenario isn't made up! It happened to us a few weeks ago. We've been happily testing early versions of `verify` for the last two weeks and haven't had any issues since.

This type of verification is only the start. If your application is deployed on-prem by your customers, `verify` could tell you if it's safe for your customers to rollback to an older version of your app, even after schema migrations have been run.

Using `verify` requires that you push your queries and schema when you tag a release of your application. We run it on every push to main, as we continuously deploy those commits.

## Authentication

`sqlc` expects to find a valid auth token in the value of the `SQLC_AUTH_TOKEN`
environment variable. You can create an auth token via the [dashboard](https://dashboard.sqlc.dev).

```shell
export SQLC_AUTH_TOKEN=sqlc_xxxxxxxx
```

## Expected workflow

Using `sqlc verify` requires pushing your queries and schema to sqlc Cloud. When
you release a new version of your application, you should push your schema and
queries as well. For example, we run `sqlc push` after any change has been
merged into our `main` branch on Github, as we deploy every commit to
production.

```shell
$ sqlc push --tag main
```

Locally or in pull requests, run `sqlc verify` to check that existing queries
continue to work with your current database schema.

```shell
$ sqlc verify --against main
```

## Picking a tag

Without an `against` argument, `verify` will run its analysis of the provided schema using your most-recently pushed queries. We suggest using the `against` argument to explicitly select a set of queries for comparison.

```shell
$ sqlc verify --against [tag]
```

================
File: docs/howto/vet.md
================
# `vet` - Linting queries

*Added in v1.19.0*

`sqlc vet` runs queries through a set of lint rules.

Rules are defined in the `sqlc` [configuration](../reference/config) file. They
consist of a name, message, and a [Common Expression Language
(CEL)](https://github.com/google/cel-spec) expression. Expressions are evaluated
using [cel-go](https://github.com/google/cel-go).  If an expression evaluates to
`true`, `sqlc vet` will report an error using the given message.

## Defining lint rules

Each lint rule's CEL expression has access to information from your sqlc
configuration and queries via variables defined in the following proto messages.

```proto
message Config
{
  string version = 1;
  string engine = 2 ;
  repeated string schema = 3;
  repeated string queries = 4;
}

message Query
{
  // SQL body
  string sql = 1;
  // Name of the query
  string name = 2; 
  // One of "many", "one", "exec", etc.
  string cmd = 3;
  // Query parameters, if any
  repeated Parameter params = 4;
}

message Parameter
{
  int32 number = 1;
}
```

In addition to this basic information, when you have a PostgreSQL or MySQL
[database connection configured](../reference/config.md#database)
each CEL expression has access to the output from running `EXPLAIN ...` on your query
via the `postgresql.explain` and `mysql.explain` variables.
This output is quite complex and depends on the structure of your query but sqlc attempts
to parse and provide as much information as it can. See
[Rules using `EXPLAIN ...` output](#rules-using-explain-output) for more information.

Here are a few example rules just using the basic configuration and query information available
to the CEL expression environment. While these examples are simplistic, they give you a flavor
of the types of rules you can write.

```yaml
version: 2
sql:
  - schema: "query.sql"
    queries: "query.sql"
    engine: "postgresql"
    gen:
      go:
        package: "authors"
        out: "db"
    rules:
      - no-pg
      - no-delete
      - only-one-param
      - no-exec
rules:
  - name: no-pg
    message: "invalid engine: postgresql"
    rule: |
      config.engine == "postgresql"
  - name: no-delete
    message: "don't use delete statements"
    rule: |
      query.sql.contains("DELETE")
  - name: only-one-param
    message: "too many parameters"
    rule: |
      query.params.size() > 1
  - name: no-exec
    message: "don't use exec"
    rule: |
      query.cmd == "exec"
```

### Rules using `EXPLAIN ...` output

*Added in v1.20.0*

The CEL expression environment has two variables containing `EXPLAIN ...` output,
`postgresql.explain` and `mysql.explain`. `sqlc` only populates the variable associated with
your configured database engine, and only when you have a
[database connection configured](../reference/config.md#database).

For the `postgresql` engine, `sqlc` runs

```sql
EXPLAIN (ANALYZE false, VERBOSE, COSTS, SETTINGS, BUFFERS, FORMAT JSON) ...
```

where `"..."` is your query string, and parses the output into a [`PostgreSQLExplain`](https://buf.build/sqlc/sqlc/docs/v1.20.0:vet#vet.PostgreSQLExplain) proto message.

For the `mysql` engine, `sqlc` runs

```sql
EXPLAIN FORMAT=JSON ...
```

where `"..."` is your query string, and parses the output into a [`MySQLExplain`](https://buf.build/sqlc/sqlc/docs/v1.20.0:vet#vet.MySQLExplain) proto message.

These proto message definitions are too long to include here, but you can find them in the `protos`
directory within the `sqlc` source tree.

The output from `EXPLAIN ...` depends on the structure of your query so it's a bit difficult
to offer generic examples. Refer to the
[PostgreSQL documentation](https://www.postgresql.org/docs/current/using-explain.html) and
[MySQL documentation](https://dev.mysql.com/doc/refman/en/explain-output.html) for more
information.

```yaml
...
rules:
- name: postgresql-query-too-costly
  message: "Query cost estimate is too high"
  rule: "postgresql.explain.plan.total_cost > 1.0"
- name: postgresql-no-seq-scan
  message: "Query plan results in a sequential scan"
  rule: "postgresql.explain.plan.node_type == 'Seq Scan'"
- name: mysql-query-too-costly
  message: "Query cost estimate is too high"
  rule: "has(mysql.explain.query_block.cost_info) && double(mysql.explain.query_block.cost_info.query_cost) > 2.0"
- name: mysql-must-use-primary-key
  message: "Query plan doesn't use primary key"
  rule: "has(mysql.explain.query_block.table.key) && mysql.explain.query_block.table.key != 'PRIMARY'"
```

When building rules that depend on `EXPLAIN ...` output, it may be helpful to see the actual JSON
returned from the database. `sqlc` will print it When you set the environment variable
`SQLCDEBUG=dumpexplain=1`. Use this environment variable together with a dummy rule to see
`EXPLAIN ...` output for all of your queries.

```yaml
version: 2
sql:
  - schema: "query.sql"
    queries: "query.sql"
    engine: "postgresql"
    database:
      uri: "postgresql://postgres:postgres@localhost:5432/postgres"
    gen:
      go:
        package: "db"
        out: "db"
    rules:
      - debug
rules:
- name: debug
  rule: "!has(postgresql.explain)" # A dummy rule to trigger explain
```

Please note that databases configured with a `uri` must have an up-to-date
schema for `vet` to work correctly, and `sqlc` does not apply schema migrations
to your database. Use your migration tool of choice to create the necessary
tables and objects before running `sqlc vet` with rules that depend on
`EXPLAIN ...` output.

Alternatively, configure [managed databases](managed-databases.md) to have
`sqlc` create hosted ephemeral databases with the correct schema automatically.

## Built-in rules

### sqlc/db-prepare

When a [database](../reference/config.md#database) connection is configured, you can
run the built-in `sqlc/db-prepare` rule. This rule will attempt to prepare
each of your queries against the connected database and report any failures.

```yaml
version: 2
sql:
  - schema: "schema.sql"
    queries: "query.sql"
    engine: "postgresql"
    gen:
      go:
        package: "authors"
        out: "db"
    database:
      uri: "postgresql://postgres:password@localhost:5432/postgres"
    rules:
      - sqlc/db-prepare
```

Please note that databases configured with a `uri` must have an up-to-date
schema for `vet` to work correctly, and `sqlc` does not apply schema migrations
to your database. Use your migration tool of choice to create the necessary
tables and objects before running `sqlc vet` with the `sqlc/db-prepare` rule.

Alternatively, configure [managed databases](managed-databases.md) to have
`sqlc` create hosted ephemeral databases with the correct schema automatically.

```yaml
version: 2
cloud:
  project: "<PROJECT_ID>"
sql:
  - schema: "schema.sql"
    queries: "query.sql"
    engine: "postgresql"
    gen:
      go:
        package: "authors"
        out: "db"
    database:
      managed: true
    rules:
      - sqlc/db-prepare
```

To see this in action, check out the [authors
example](https://github.com/sqlc-dev/sqlc/blob/main/examples/authors/sqlc.yaml).

## Running lint rules

When you add the name of a defined rule to the rules list
for a [sql package](../reference/config.md#sql),
`sqlc vet` will evaluate that rule against every query in the package.

In the example below, two rules are defined but only one is enabled.

```yaml
version: 2
sql:
  - schema: "query.sql"
    queries: "query.sql"
    engine: "postgresql"
    gen:
      go:
        package: "authors"
        out: "db"
    rules:
      - no-delete
rules:
  - name: no-pg
    message: "invalid engine: postgresql"
    rule: |
      config.engine == "postgresql"
  - name: no-delete
    message: "don't use delete statements"
    rule: |
      query.sql.contains("DELETE")
```

### Opting-out of lint rules

For any query, you can tell `sqlc vet` not to evaluate lint rules using the
`@sqlc-vet-disable` query annotation. The annotation accepts a list of rules to ignore.

```sql
/* name: GetAuthor :one */
/* @sqlc-vet-disable sqlc/db-prepare no-pg */
SELECT * FROM authors
WHERE id = ? LIMIT 1;
```
The rules can also be split across lines.
```sql
/* name: GetAuthor :one */
/* @sqlc-vet-disable sqlc/db-prepare */
/* @sqlc-vet-disable no-pg */
SELECT * FROM authors
WHERE id = ? LIMIT 1;
```

To skip all rules for a query, you can provide the `@sqlc-vet-disable` annotation without any parameters. 

```sql
/* name: GetAuthor :one */
/* @sqlc-vet-disable */
SELECT * FROM authors
WHERE id = ? LIMIT 1;
```

================
File: docs/overview/install.md
================
# Installing sqlc

sqlc is distributed as a single binary with zero dependencies.

## macOS

```
brew install sqlc
```

## Ubuntu

```
sudo snap install sqlc
```

## go install

Installing recent versions of sqlc requires Go 1.21+.

```
go install github.com/sqlc-dev/sqlc/cmd/sqlc@latest
```

## Docker

```
docker pull sqlc/sqlc
```

Run `sqlc` using `docker run`:

```
docker run --rm -v $(pwd):/src -w /src sqlc/sqlc generate
```

Run `sqlc` using `docker run` in the Command Prompt on Windows (`cmd`):

```
docker run --rm -v "%cd%:/src" -w /src sqlc/sqlc generate
```

## Downloads

Get pre-built binaries for *v1.28.0*:

- [Linux](https://downloads.sqlc.dev/sqlc_1.28.0_linux_amd64.tar.gz)
- [macOS](https://downloads.sqlc.dev/sqlc_1.28.0_darwin_amd64.zip)
- [Windows](https://downloads.sqlc.dev/sqlc_1.28.0_windows_amd64.zip)

See [downloads.sqlc.dev](https://downloads.sqlc.dev/) for older versions.

================
File: docs/reference/changelog.md
================
# Changelog
All notable changes to this project will be documented in this file.

(v1-28-0)=
## [1.28.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.28.0)
Released 2025-01-20

### Features

- (mysql) Add a test for VECTOR column type (#3734)
- (quickdb) Remove unused func (#3576)
- (vet) Allow selective disabling of rules per query (#3620)
- (dolphin) Upgrade to latest TiDB parser (#3733)

### Bug Fixes

- (dbmanager) Use correct SQL to drop databases (#3640)
- (compiler) Don't crash on WHERE x IN (... UNION ...) (#3652)
- (golang) Escape q field name (#3647)
- Postgresql alter materialized view is not registered to statements (#3728)
- Do not close wazero module on error (#3758) (#3759)

### Documentation

- How-to use transactions with pgx (#3557)
- Add missing documentation about copyfrom (#3583)
- Add sqlc-gen-from-template (#3601)
- Correct spelling and grammar (#3645)

### Miscellaneous Tasks

- Remove the triage label (#3527)
- Upgrade to Go 1.22.8 to silence vulncheck (#3646)

### Build

- (deps) Bump myst-parser (#3530)
- (deps) Bump golang from 1.22.5 to 1.22.6 (#3532)
- (deps) Bump modernc.org/sqlite (#3537)
- (deps) Bump the production-dependencies group across 1 directory with 4 updates (#3566)
- (deps) Bump the production-dependencies group across 1 directory with 2 updates (#3565)
- (deps) Bump golang from 1.22.6 to 1.23.0 (#3546)
- (deps) Bump golang from 1.23.0 to 1.23.1 (#3586)
- (deps) Bump the production-dependencies group across 1 directory with 5 updates (#3644)
- (deps) Bump the production-dependencies group across 1 directory with 5 updates (#3642)
- (deps) Bump sphinx-rtd-theme (#3648)
- (deps) Bump pyparsing (#3653)
- (deps) Bump markupsafe (#3666)
- (deps) Bump the production-dependencies group across 1 directory with 2 updates (#3707)
- (deps) Bump golang from 1.23.2 to 1.23.3 (#3691)
- (deps) Bump the production-dependencies group across 1 directory with 5 updates (#3721)
- (deps) Bump the production-dependencies group across 1 directory with 2 updates (#3731)
- (deps) Bump certifi in /docs in the production-dependencies group (#3748)
- (deps) Bump golang.org/x/crypto from 0.27.0 to 0.31.0 (#3740)
- (deps) Bump golang from 1.23.3 to 1.23.4 (#3735)
- (deps) Bump the production-dependencies group across 1 directory with 2 updates (#3749)
- (deps) Bump the production-dependencies group with 2 updates (#3753)
- (deps) Bump the production-dependencies group across 1 directory with 3 updates (#3764)
- (deps) Bump the production-dependencies group (#3761)
- (deps) Bump jinja2 from 3.1.4 to 3.1.5 in /docs (#3762)
- (deps) Bump google.golang.org/protobuf (#3776)
- (deps) Bump the production-dependencies group across 1 directory with 2 updates (#3777)
- (deps) Bump google.golang.org/grpc (#3784)
- (deps) Bump golang from 1.23.4 to 1.23.5 (#3791)
- (deps) Bump the production-dependencies group with 2 updates (#3789)
- Upgrade to Go 1.23.5 (#3795)

(v1-27-0)=
## [1.27.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.27.0)
Released 2024-08-05

### Bug Fixes

- (dbmanager) Add leading slash to db uri path rewrite (#3493)
- (verify) Include database engine in request (#3522)

### Features

- (golang) Add initialisms configuration (#3308)
- (compiler) Support subqueries in the FROM clause (second coming) (#3310)
- Managed databases with any accessible server  (#3421)
- (vet) Use new dbmanager client (#3423)
- (verify) Update verify to work with managed databases (#3425)

### Documentation

- Fix typo in config (#3358)
- Resolve a typo in configuration keys (#3349)
- Add sponsorship information to README (#3413)
- Update the language-support to include C# (#3408)
- Add migration guide for hosted managed databases (#3417)
- Fix readme links (#3424)
- Update the managed db and verify documentation (#3426)
- Add sponsor image (#3428)
- Add Ruby as supported language (#3487)
- Update migrating-to-sqlc-gen-kotlin.md (#3454)
- Fix typo in comment (#3316)
- Fix deprecated build tag format (#3361)

### Testing

- (endtoend) Re-use databases when possible (#3315)
- Enabled MySQL database (#3318)
- Remove internal/sqltest/hosted package (#3521)

(v1-26-0)=
## [1.26.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.26.0)
Released 2024-03-28

### Release notes

This release is mainly a bug fix release. It also includes an [important security fix](https://github.com/sqlc-dev/sqlc/issues/3194) for users using output plugins.

### Changes

#### Bug Fixes

- (docker) Use distroless base image instead of scratch (#3111)
- (generate) Ensure files are created inside output directory (#3195)
- (mysql) BREAKING: Use `int16` for MySQL `SMALLINT` and `YEAR` (#3106)
- (mysql) BREAKING: Use `int8` for MySQL TINYINT (#3298)
- (mysql) Variables not resolving in ORDER BY statements (#3115)
- (opts) Validate SQL package and driver options (#3241)
- (postgres/batch) Ignore query_parameter_limit for batches
- (scripts) Remove deprecated test output regeneration script (#3105)
- (sqlite) Correctly skip unknown statements (#3239)

#### Documentation

- (postgres) Add instructions for PostGIS/GEOS (#3182)
- Improve details on TEXT (#3247)

#### Features

- (generate) Avoid generating empty Go imports (#3135)
- (mysql) Add NEXTVAL() to the MySQL catalog (#3147)
- (mysql) Support json.RawMessage for LOAD DATA INFILE (#3099)

#### Build

- (deps) Bump github.com/jackc/pgx/v5 to 5.5.5 (#3259)
- (deps) Bump modernc.org/sqlite to 1.29.5 (#3200)
- (deps) Bump github.com/go-sql-driver/mysql to 1.8.0 (#3257)
- (deps) Bump github.com/tetratelabs/wazero to 1.7.0 (#3096)
- (deps) Bump github.com/pganalyze/pg_query_go to v5 (#3096)


(v1-25-0)=
## [1.25.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.25.0)
Released 2024-01-03

### Release notes

#### Add tags to push and verify

You can add tags when [pushing](../howto/push.md) schema and queries to [sqlc Cloud](https://dashboard.sqlc.dev). Tags operate like git tags, meaning you can overwrite previously-pushed tag values. We suggest tagging pushes to associate them with something relevant from your environment, e.g. a git tag or branch name.

```
$ sqlc push --tag v1.0.0
```

Once you've created a tag, you can refer to it when [verifying](../howto/verify.md) changes, allowing you
to compare the existing schema against a known set of previous queries.

```
$ sqlc verify --against v1.0.0
```

#### C-ya, `cgo`

Over the last month, we've switched out a few different modules to remove our reliance on [cgo](https://go.dev/blog/cgo). Previously, we needed cgo for three separate functions:

- Parsing PostgreSQL queries with [pganalyze/pg_query_go](https://github.com/pganalyze/pg_query_go)
- Running SQLite databases with [mattn/go-sqlite3](https://github.com/mattn/go-sqlite3)
- Executing WASM / WASI code with [bytecodealliance/wasmtime-go](https://github.com/bytecodealliance/wasmtime-go)

With the help of the community, we found cgo-free alternatives for each module:

- Parsing PostgreSQL queries, now using [wasilibs/go-pgquery](https://github.com/wasilibs/go-pgquery)
- Running SQLite databases, now using [modernc.org/sqlite](https://gitlab.com/cznic/sqlite)
- Executing WASM / WASI code, now using [tetratelabs/wazero](https://github.com/tetratelabs/wazero)

For the first time, Windows users can enjoy full PostgreSQL support without using [WSL](https://learn.microsoft.com/en-us/windows/wsl/about). It's a Christmas miracle!

If you run into any issues with the updated dependencies, please [open an issue](https://github.com/sqlc-dev/sqlc/issues).

### Changes 

#### Bug Fixes

- (codegen) Wrong yaml annotation in go codegen options for output_querier_file_name (#3006)
- (codegen) Use derived ArrayDims instead of deprecated attndims (#3032)
- (codegen) Take the maximum array dimensions (#3034)
- (compiler) Skip analysis of queries without a `name` annotation (#3072)
- (codegen/golang) Don't import `"strings"` for `sqlc.slice()` with pgx (#3073)

### Documentation

- Add name to query set configuration (#3011)
- Add a sidebar link for `push`, add Go plugin link (#3023)
- Update banner for sqlc-gen-typescript (#3036)
- Add strict_order_by in doc (#3044)
- Re-order the migration tools list (#3064)

### Features

- (analyzer) Return zero values when encountering unexpected ast nodes (#3069)
- (codegen/go) add omit_sqlc_version to Go code generation (#3019)
- (codgen/go) Add `emit_sql_as_comment` option to Go code plugin (#2735)
- (plugins) Use wazero instead of wasmtime (#3042)
- (push) Add tag support (#3074)
- (sqlite) Support emit_pointers_for_null_types (#3026)

### Testing

- (endtoend) Enable for more build targets (#3041)
- (endtoend) Run MySQL and PostgreSQL locally on the runner (#3095)
- (typescript) Test against sqlc-gen-typescript (#3046)
- Add tests for omit_sqlc_version (#3020)
- Split schema and query for test (#3094)

### Build

- (deps) Bump idna from 3.4 to 3.6 in /docs (#3010)
- (deps) Bump sphinx-rtd-theme from 1.3.0 to 2.0.0 in /docs (#3016)
- (deps) Bump golang from 1.21.4 to 1.21.5 (#3043)
- (deps) Bump actions/setup-go from 4 to 5 (#3047)
- (deps) Bump github.com/jackc/pgx/v5 from 5.5.0 to 5.5.1 (#3050)
- (deps) Upgrade to latest version of github.com/wasilibs/go-pgquery (#3052)
- (deps) Bump google.golang.org/grpc from 1.59.0 to 1.60.0 (#3053)
- (deps) Bump babel from 2.13.1 to 2.14.0 in /docs (#3055)
- (deps) Bump actions/upload-artifact from 3 to 4 (#3061)
- (deps) Bump modernc.org/sqlite from 1.27.0 to 1.28.0 (#3062)
- (deps) Bump golang.org/x/crypto from 0.14.0 to 0.17.0 (#3068)
- (deps) Bump google.golang.org/grpc from 1.60.0 to 1.60.1 (#3070)
- (deps) Bump google.golang.org/protobuf from 1.31.0 to 1.32.0 (#3079)
- (deps) Bump github.com/tetratelabs/wazero from 1.5.0 to 1.6.0 (#3096)
- (sqlite) Update to antlr 4.13.1 (#3086)
- (sqlite) Disable modernc for WASM (#3048)
- (sqlite) Switch from mattn/go-sqlite3 to modernc.org/sqlite (#3040)

(v1-24-0)=
## [1.24.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.24.0)
Released 2023-11-22

### Release notes

#### Verifying database schema changes

Schema updates and poorly-written queries often bring down production databases. That’s bad.

Out of the box, `sqlc generate` catches some of these issues. Running `sqlc vet` with the `sqlc/db-prepare` rule catches more subtle problems. But there is a large class of issues that sqlc can’t prevent by looking at current schema and queries alone.

For instance, when a schema change is proposed, existing queries and code running in production might fail when the schema change is applied. Enter `sqlc verify`, which analyzes existing queries against new schema changes and errors if there are any issues.

Let's look at an example. Assume you have these two tables in production.

```sql
CREATE TABLE users (
  id UUID PRIMARY KEY
);

CREATE TABLE user_actions (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL,
  action TEXT,
  created_at TIMESTAMP
);
```

Your application contains the following query to join user actions against the users table.

```sql
-- name: GetUserActions :many
SELECT * FROM users u
JOIN user_actions ua ON u.id = ua.user_id
ORDER BY created_at;
```

So far, so good. Then assume you propose this schema change:

```sql
ALTER TABLE users ADD COLUMN created_at TIMESTAMP;
```

Running `sqlc generate` fails with this change, returning a `column reference "created_at" is ambiguous` error. You update your query to fix the issue.

```sql
-- name: GetUserActions :many
SELECT * FROM users u
JOIN user_actions ua ON u.id = ua.user_id
ORDER BY u.created_at;
```

While that change fixes the issue, there's a production outage waiting to happen. When the schema change is applied, the existing `GetUserActions` query will begin to fail. The correct way to fix this is to deploy the updated query before applying the schema migration.

It ensures migrations are safe to deploy by sending your current schema and queries to sqlc cloud. There, we run the queries for your latest push against your new schema changes. This check catches backwards incompatible schema changes for existing queries.

Here `sqlc verify` alerts you to the fact that ORDER BY "created_at" is ambiguous.

```sh
$ sqlc verify
FAIL: app query.sql

=== Failed
=== FAIL: app query.sql GetUserActions
    ERROR: column reference "created_at" is ambiguous (SQLSTATE 42702)
```

By the way, this scenario isn't made up! It happened to us a few weeks ago. We've been happily testing early versions of `verify` for the last two weeks and haven't had any issues since.

This type of verification is only the start. If your application is deployed on-prem by your customers, `verify` could tell you if it's safe for your customers to rollback to an older version of your app, even after schema migrations have been run.

#### Rename `upload` command to `push`

We've renamed the `upload` sub-command to `push`. We changed the data sent along in a push request. Upload used to include the configuration file, migrations, queries, and all generated code. Push drops the generated code in favor of including the [plugin.GenerateRequest](https://buf.build/sqlc/sqlc/docs/main:plugin#plugin.GenerateRequest), which is the protocol buffer message we pass to codegen plugins.

We also add annotations to each push. By default, we include these environment variables if they are present:

```
GITHUB_REPOSITORY
GITHUB_REF
GITHUB_REF_NAME
GITHUB_REF_TYPE
GITHUB_SHA
```

Like upload, `push` should be run when you tag a release of your application. We run it on every push to main, as we continuously deploy those commits.

#### MySQL support in `createdb`

The `createdb` command, added in the last release, now supports MySQL. If you have a cloud project configured, you can use `sqlc createdb` to spin up a new ephemeral database with your schema and print its connection string to standard output. This is useful for integrating with other tools. Read more in the [managed databases](../howto/managed-databases.md#with-other-tools) documentation.

#### Plugin interface refactor

This release includes a refactored plugin interface to better support future functionality. Plugins now support different methods via a gRPC service interface, allowing plugins to support different functionality in a backwards-compatible way.

By using gRPC interfaces, we can even (theoretically) support [remote plugins](https://github.com/sqlc-dev/sqlc/pull/2938), but that's something for another day.

### Changes

#### Bug Fixes

- (engine/sqlite) Support CASE expr (#2926)
- (engine/sqlite) Support -> and ->> operators (#2927)
- (vet) Add a nil pointer check to prevent db/prepare panic (#2934)
- (compiler) Prevent panic when compiler is nil (#2942)
- (codegen/golang) Move more Go-specific config validation into the plugin (#2951)
- (compiler) No panic on full-qualified column names (#2956)
- (docs) Better discussion of type override nuances (#2972)
- (codegen) Never generate return structs for :exec (#2976)
- (generate) Update help text for generate to be more generic (#2981)
- (generate) Return an error instead of generating duplicate Go names (#2962)
- (codegen/golang) Pull opts into its own package (#2920)
- (config) Make some struct and field names less confusing (#2922)

#### Features

- (codegen) Remove Go specific overrides from codegen proto (#2929)
- (plugin) Use gRPC interface for codegen plugin communication (#2930)
- (plugin) Calculate SHA256 if it does not exist (#2935)
- (sqlc-gen-go) Add script to mirror code to sqlc-gen-go (#2952)
- (createdb) Add support for MySQL (#2980)
- (verify) Add new command to verify queries and migrations (#2986)

#### Testing

- (ci) New workflow for sqlc-gen-python (#2936)
- (ci) Rely on go.mod to determine which Go version to use (#2971)
- (tests) Add glob pattern tests to sqlpath.Glob (#2995)
- (examples) Use hosted MySQL databases for tests (#2982)
- (docs) Clean up a little, update LICENSE and README (#2941)

#### Build

- (deps) Bump babel from 2.13.0 to 2.13.1 in /docs (#2911)
- (deps) Bump github.com/spf13/cobra from 1.7.0 to 1.8.0 (#2944)
- (deps) Bump github.com/mattn/go-sqlite3 from 1.14.17 to 1.14.18 (#2945)
- (deps) Bump golang.org/x/sync from 0.4.0 to 0.5.0 (#2946)
- (deps) Bump github.com/jackc/pgx/v5 from 5.4.3 to 5.5.0 (#2947)
- (deps) Change github.com/pingcap/tidb/parser to github.com/pingcap/tidb/pkg/parser
- (deps) Bump github.com/google/cel-go from 0.18.1 to 0.18.2 (#2969)
- (deps) Bump urllib3 from 2.0.7 to 2.1.0 in /docs (#2975)
- (buf) Change root of Buf module (#2987)
- (deps) Bump certifi from 2023.7.22 to 2023.11.17 in /docs (#2993)
- (ci) Bump Go version from 1.21.3 to 1.21.4 in workflows and Dockerfile (#2961)

(v1-23-0)=
## [1.23.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.23.0)
Released 2023-10-24

### Release notes

#### Database-backed query analysis

With a [database connection](config.md#database) configured, `sqlc generate`
will gather metadata from that database to support its query analysis.
Turning this on resolves a [large number of
issues](https://github.com/sqlc-dev/sqlc/issues?q=is%3Aissue+label%3Aanalyzer)
in the backlog related to type inference and more complex queries. The easiest
way to try it out is with [managed databases](../howto/managed-databases.md).

The database-backed analyzer currently supports PostgreSQL, with [MySQL](https://github.com/sqlc-dev/sqlc/issues/2902) and [SQLite](https://github.com/sqlc-dev/sqlc/issues/2903)
support planned in the future.

#### New `createdb` command

When you have a cloud project configured, you can use the new `sqlc createdb`
command to spin up a new ephemeral database with your schema and print its
connection string to standard output. This is useful for integrating with other
tools. Read more in the [managed
databases](../howto/managed-databases.md#with-other-tools) documentation.

#### Support for pgvector

If you're using [pgvector](https://github.com/pgvector/pgvector), say goodbye to custom overrides! sqlc now generates code using [pgvector-go](https://github.com/pgvector/pgvector-go#pgx) as long as you're using `pgx`. The pgvector extension is also available in [managed databases](../howto/managed-databases.md).

#### Go build tags

With the new `emit_build_tags` configuration parameter you can set build tags
for sqlc to add at the top of generated source files.

### Changes

#### Bug Fixes

- (codegen) Correct column names in :copyfrom (#2838)
- (compiler) Search SELECT and UPDATE the same way (#2841)
- (dolphin) Support more UNIONs for MySQL (#2843)
- (compiler) Account for parameters without parents (#2844)
- (postgresql) Remove temporary pool config (#2851)
- (golang) Escape reserved keywords (#2849)
- (mysql) Handle simplified CASE statements (#2852)
- (engine/dolphin) Support enum in ALTER definition (#2680)
- (mysql) Add, drop, rename and change enum values (#2853)
- (config) Validate `database` config in all cases (#2856)
- (compiler) Use correct func signature for `CommentSyntax` on windows (#2867)
- (codegen/go) Prevent filtering of embedded struct fields (#2868)
- (compiler) Support functions with OUT params (#2865)
- (compiler) Pull in array information from analyzer (#2864)
- (analyzer) Error on unexpanded star expression (#2882)
- (vet) Remove rollback statements from DDL (#2895)

#### Documentation

- Add stable anchors to changelog (#2784)
- Fix typo in v1.22.0 changelog (#2796)
- Add sqlc upload to CI / CD guide (#2797)
- Fix broken link, add clarity to plugins doc (#2813)
- Add clarity and reference to JSON tags (#2819)
- Replace form with dashboard link (#2840)
- (examples) Update examples to use pgx/v5 (#2863)
- Use docker compose v2 and update MYSQL_DATABASE env var (#2870)
- Update getting started guides, use pgx for Postgres guide (#2891)
- Use managed databases in PostgreSQL getting started guide (#2892)
- Update managed databases doc to discuss codegen (#2897)
- Add managed dbs to CI/CD and vet guides (#2896)
- Document database-backed query analyzer (#2904)

#### Features

- (codegen) Support setting Go build tags (#2012) (#2807)
- (generate) Reorder codegen handlers to prefer plugins (#2814)
- (devenv) Add vscode settings.json with auto newline (#2834)
- (cmd) Support sqlc.yml configuration file (#2828)
- (analyzer) Analyze queries using a running PostgreSQL database (#2805)
- (sql/ast) Render AST to SQL (#2815)
- (codegen) Include plugin information (#2846)
- (postgresql) Add ALTER VIEW ... SET SCHEMA (#2855)
- (compiler) Parse query parameter metadata from comments (#2850)
- (postgresql) Support system columns on tables (#2871)
- (compiler) Support LEFT JOIN on aliased table (#2873)
- Improve messaging for common cloud config and rpc errors (#2885)
- Abort compiler when rpc fails as unauthenticated (#2887)
- (codegen) Add support for pgvector and pgvector-go (#2888)
- (analyzer) Cache query analysis (#2889)
- (createdb) Create ephemeral databases (#2894)
- (debug) Add databases=managed debug option (#2898)
- (config) Remove managed database validation (#2901)

#### Miscellaneous Tasks

- (endtoend) Fix test output for do tests (#2782)

#### Refactor

- (codegen) Remove golang and json settings from plugin proto (#2822)
- (codegen) Removed deprecated code and improved speed (#2899)

#### Testing

- (endtoend) Split shema and queries (#2803)
- Fix a few incorrect testcases (#2804)
- (analyzer) Add more database analyzer test cases (#2854)
- Add more analyzer test cases (#2866)
- Add more test cases for new analyzer (#2879)
- (endtoend) Enabled managed-db tests in CI (#2883)
- Enabled pgvector tests for managed dbs (#2893)

#### Build

- (deps) Bump packaging from 23.1 to 23.2 in /docs (#2791)
- (deps) Bump urllib3 from 2.0.5 to 2.0.6 in /docs (#2798)
- (deps) Bump babel from 2.12.1 to 2.13.0 in /docs (#2799)
- (deps) Bump golang.org/x/sync from 0.3.0 to 0.4.0 (#2810)
- (deps) Bump golang from 1.21.1 to 1.21.2 (#2811)
- (deps) Bump github.com/google/go-cmp from 0.5.9 to 0.6.0 (#2826)
- (deps) Bump golang from 1.21.2 to 1.21.3 (#2824)
- (deps) Bump google.golang.org/grpc from 1.58.2 to 1.58.3 (#2825)
- (deps) Bump golang.org/x/net from 0.12.0 to 0.17.0 (#2836)
- (deps) Bump urllib3 from 2.0.6 to 2.0.7 in /docs (#2872)
- (deps) Bump google.golang.org/grpc from 1.58.3 to 1.59.0 (#2876)
- (deps) Upgrade wasmtime-go from 13.0.0 to 14.0.0 (#2900)

#### Ci

- Bump go version in workflows (#2835)


(v1-22-0)=
## [1.22.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.22.0)
Released 2023-09-26

### Release notes

#### Managed databases for `sqlc vet`

If you're using [sqlc vet](../howto/vet.md) to write rules that require access to a running
database, `sqlc` can now start and manage that database for you. PostgreSQL
support is available today, with MySQL on the way.

When you turn on managed databases, `sqlc` will use your schema to create a
template database that it can copy to make future runs of `sqlc vet` very
performant.

This feature relies on configuration obtained via [sqlc
Cloud](https://dashboard.sqlc.dev).

Read more in the [managed databases](../howto/managed-databases.md) documentation.

### Changes

#### Bug Fixes

- (codegen/golang) Refactor imports code to match templates (#2709)
- (codegen/golang) Support name type (#2715)
- (wasm) Move Runner struct to shared file (#2725)
- (engine/sqlite) Fix grammer to avoid missing join_constraint (#2732)
- (convert) Support YAML anchors in plugin options (#2733)
- (mysql) Disallow time.Time in mysql :copyfrom queries, not all queries (#2768)
- (engine/sqlite) Fix convert process for VALUES (#2737)

#### Documentation

- Clarify nullable override behavior (#2753)
- Add managed databases to sidebar (#2764)
- Pull renaming and type overrides into separate sections (#2774)
- Update the docs banner for managed dbs (#2775)

#### Features

- (config) Enables the configuration of copyfrom.go similar to quierer and friends (#2727)
- (vet) Run rules against a managed database (#2751)
- (upload) Point upload command at new endpoint (#2772)
- (compiler) Support DO statements (#2777)

#### Miscellaneous Tasks

- (endtoend) Skip tests missing secrets (#2763)
- Skip certain tests on PRs (#2769)

#### Testing

- (endtoend) Verify all schemas in endtoend (#2744)
- (examples) Use a hosted database for example testing (#2749)
- (endtoend) Pull region from environment (#2750)

#### Build

- (deps) Bump golang from 1.21.0 to 1.21.1 (#2711)
- (deps) Bump google.golang.org/grpc from 1.57.0 to 1.58.1 (#2743)
- (deps) Bump wasmtime-go from v12 to v13 (#2756)
- (windows) Downgrade to mingw 11.2.0 (#2757)
- (deps) Bump urllib3 from 2.0.4 to 2.0.5 in /docs (#2747)
- (deps) Bump google.golang.org/grpc from 1.58.1 to 1.58.2 (#2758)
- (deps) Bump github.com/google/cel-go from 0.18.0 to 0.18.1 (#2778)

#### Ci

- Bump go version to latest in ci workflows (#2722)


(v1-21-0)=
## [1.21.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.21.0)
Released 2023-09-06

### Release notes

This is primarily a bugfix release, along with some documentation and testing improvements.

#### MySQL engine improvements

`sqlc` previously didn't know how to parse a `CALL` statement when using the MySQL engine,
which meant it was impossible to use sqlc with stored procedures in MySQL databases.

Additionally, `sqlc` now supports `IS [NOT] NULL` in queries. And `LIMIT` and `OFFSET` clauses
now work with `UNION`.

#### SQLite engine improvements

GitHub user [@orisano](https://github.com/orisano) continues to bring bugfixes and
improvements to `sqlc`'s SQLite engine. See the "Changes" section below for the
full list.

#### Plugin access to environment variables

If you're authoring a [sqlc plugin](../guides/plugins.html), you can now configure
sqlc to pass your plugin the values of specific environment variables.

For example, if your plugin
needs the `PATH` environment variable, add `PATH` to the `env` list in the
`plugins` collection.

```yaml
version: '2'
sql:
- schema: schema.sql
  queries: query.sql
  engine: postgresql
  codegen:
  - out: gen
    plugin: test
plugins:
- name: test
  env:
  - PATH
  wasm:
    url: https://github.com/sqlc-dev/sqlc-gen-test/releases/download/v0.1.0/sqlc-gen-test.wasm
    sha256: 138220eae508d4b65a5a8cea555edd155eb2290daf576b7a8b96949acfeb3790
```

A variable named `SQLC_VERSION` is always included in the plugin's
environment, set to the version of the `sqlc` executable invoking it.

### Changes

#### Bug Fixes

- Myriad string formatting changes (#2558)
- (engine/sqlite) Support quoted identifier (#2556)
- (engine/sqlite) Fix compile error (#2564)
- (engine/sqlite) Fixed detection of column alias without AS (#2560)
- (ci) Bump go version to 1.20.7 (#2568)
- Remove references to deprecated `--experimental` flag (#2567)
- (postgres) Fixed a problem with array dimensions disappearing when using "ALTER TABLE ADD COLUMN" (#2572)
- Remove GitHub sponsor integration (#2574)
- (docs) Improve discussion of prepared statements support (#2604)
- (docs) Remove multidimensional array qualification in datatypes.md (#2619)
- (config) Go struct tag parsing (#2606)
- (compiler) Fix to not scan children under ast.RangeSubselect when retrieving table listing (#2573)
- (engine/sqlite) Support NOT IN (#2587)
- (codegen/golang) Fixed detection of the used package (#2597)
- (engine/dolphin) Fixed problem that LIMIT OFFSET cannot be used with `UNION ALL` (#2613)
- (compiler) Support identifiers with schema (#2579)
- (compiler) Fix column expansion to work with quoted non-keyword identifiers (#2576)
- (codegen/go) Compare define type in codegen (#2263) (#2578)
- (engine/sqlite) Fix ast when using compound operator (#2673)
- (engine/sqlite) Fix to handle join clauses correctly (#2674)
- (codegen) Use correct Go types for bit strings and cid/oid/tid/xid with pgx/v4 (#2668)
- (endtoend) Ensure all SQL works against PostgreSQL (#2684)

#### Documentation

- Update Docker installation instructions (#2552)
- Missing emit_pointers_for_null_types configuration option in version 2 (#2682) (#2683)
- Fix typo (#2697)
- Document sqlc.* macros (#2698)
- (mysql) Document parseTimet=true requirement (#2699)
- Add atlas to the list of supported migration frameworks (#2700)
- Minor updates to insert howto (#2701)

#### Features

- (endtoend/testdata) Added two sqlite `CAST` tests and rearranged postgres tests for same (#2551)
- (docs) Add a reference to type overriding in datatypes.md (#2557)
- (engine/sqlite) Support COLLATE for sqlite WHERE clause (#2554)
- (mysql) Add parser support for IS [NOT] NULL (#2651)
- (engine/dolphin) Support CALL statement (#2614)
- (codegen) Allow plugins to access environment variables (#2669)
- (config) Add JSON schema files for configs (#2703)

#### Miscellaneous Tasks

- Ignore Vim swap files (#2616)
- Fix typo (#2696)

#### Refactor

- (astutils) Remove redundant nil check in `Walk` (#2660)

#### Build

- (deps) Bump wasmtime from v8.0.0 to v11.0.0 (#2553)
- (deps) Bump golang from 1.20.6 to 1.20.7 (#2563)
- (deps) Bump chardet from 5.1.0 to 5.2.0 in /docs (#2562)
- (deps) Bump github.com/pganalyze/pg_query_go/v4 (#2583)
- (deps) Bump golang from 1.20.7 to 1.21.0 (#2596)
- (deps) Bump github.com/jackc/pgx/v5 from 5.4.2 to 5.4.3 (#2582)
- (deps) Bump pygments from 2.15.1 to 2.16.1 in /docs (#2584)
- (deps) Bump sphinxcontrib-applehelp from 1.0.4 to 1.0.7 in /docs (#2620)
- (deps) Bump sphinxcontrib-qthelp from 1.0.3 to 1.0.6 in /docs (#2622)
- (deps) Bump github.com/google/cel-go from 0.17.1 to 0.17.6 (#2650)
- (deps) Bump sphinxcontrib-serializinghtml in /docs (#2641)
- Upgrade from Go 1.20 to Go 1.21 (#2665)
- (deps) Bump sphinxcontrib-devhelp from 1.0.2 to 1.0.5 in /docs (#2621)
- (deps) Bump github.com/bytecodealliance/wasmtime-go from v11.0.0 to v12.0.0 (#2666)
- (deps) Bump sphinx-rtd-theme from 1.2.2 to 1.3.0 in /docs (#2670)
- (deps) Bump sphinxcontrib-htmlhelp from 2.0.1 to 2.0.4 in /docs (#2671)
- (deps) Bump github.com/google/cel-go from 0.17.6 to 0.18.0 (#2691)
- (deps) Bump actions/checkout from 3 to 4 (#2694)
- (deps) Bump pytz from 2023.3 to 2023.3.post1 in /docs (#2695)
- (devenv) Bump go from 1.20.7 to 1.21.0 (#2702)

(v1-20-0)=
## [1.20.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.20.0)
Released 2023-07-31

### Release notes

#### `kyleconroy/sqlc` is now `sqlc-dev/sqlc`

We've completed our migration to the [sqlc-dev/sqlc](https://github.com/sqlc-dev/sqlc) repository. All existing links and installation instructions will continue to work. If you're using the `go` tool to install `sqlc`, you'll need to use the new import path to get v1.20.0 (and all future versions).

```sh
# INCORRECT: old import path
go install github.com/kyleconroy/sqlc/cmd/sqlc@v1.20.0

# CORRECT: new import path
go install github.com/sqlc-dev/sqlc/cmd/sqlc@v1.20.0
```

We designed the upgrade process to be as smooth as possible. If you run into any issues, please [file a bug report](https://github.com/sqlc-dev/sqlc/issues/new?assignees=&labels=bug%2Ctriage&projects=&template=BUG_REPORT.yml) via GitHub.

#### Use `EXPLAIN ...` output in lint rules

`sqlc vet` can now run `EXPLAIN` on your queries and include the results for use in your lint rules. For example, this rule checks that `SELECT` queries use an index.

```yaml
version: 2
sql:
  - schema: "query.sql"
    queries: "query.sql"
    engine: "postgresql"
    database:
      uri: "postgresql://postgres:postgres@localhost:5432/postgres"
    gen:
      go:
        package: "db"
        out: "db"
    rules:
      - has-index
rules:
- name: has-index
  rule: >
    query.sql.startsWith("SELECT") &&
    !(postgresql.explain.plan.plans.all(p, has(p.index_name) || p.plans.all(p, has(p.index_name))))
```

The expression environment has two variables containing `EXPLAIN ...` output, `postgresql.explain` and `mysql.explain`. `sqlc` only populates the variable associated with your configured database engine, and only when you have a [database connection configured](../reference/config.md#database).

For the `postgresql` engine, `sqlc` runs

```sql
EXPLAIN (ANALYZE false, VERBOSE, COSTS, SETTINGS, BUFFERS, FORMAT JSON) ...
```

where `"..."` is your query string, and parses the output into a [`PostgreSQLExplain`](https://buf.build/sqlc/sqlc/docs/v1.20.0:vet#vet.PostgreSQLExplain) proto message.

For the `mysql` engine, `sqlc` runs

```sql
EXPLAIN FORMAT=JSON ...
```

where `"..."` is your query string, and parses the output into a [`MySQLExplain`](https://buf.build/sqlc/sqlc/docs/v1.20.0:vet#vet.MySQLExplain) proto message.

These proto message definitions are too long to include here, but you can find them in the `protos` directory within the `sqlc` source tree.

The output from `EXPLAIN ...` depends on the structure of your query so it's a bit difficult to offer generic examples. Refer to the [PostgreSQL documentation](https://www.postgresql.org/docs/current/using-explain.html) and [MySQL documentation](https://dev.mysql.com/doc/refman/en/explain-output.html) for more information.

```yaml
...
rules:
- name: postgresql-query-too-costly
  message: "Query cost estimate is too high"
  rule: "postgresql.explain.plan.total_cost > 1.0"
- name: postgresql-no-seq-scan
  message: "Query plan results in a sequential scan"
  rule: "postgresql.explain.plan.node_type == 'Seq Scan'"
- name: mysql-query-too-costly
  message: "Query cost estimate is too high"
  rule: "has(mysql.explain.query_block.cost_info) && double(mysql.explain.query_block.cost_info.query_cost) > 2.0"
- name: mysql-must-use-primary-key
  message: "Query plan doesn't use primary key"
  rule: "has(mysql.explain.query_block.table.key) && mysql.explain.query_block.table.key != 'PRIMARY'"
```

When building rules that depend on `EXPLAIN ...` output, it may be helpful to see the actual JSON returned from the database. `sqlc` will print it When you set the environment variable `SQLCDEBUG=dumpexplain=1`. Use this environment variable together with a dummy rule to see `EXPLAIN ...` output for all of your queries.

#### Opting-out of lint rules

For any query, you can tell `sqlc vet` not to evaluate lint rules using the `@sqlc-vet-disable` query annotation.

```sql
/* name: GetAuthor :one */
/* @sqlc-vet-disable */
SELECT * FROM authors
WHERE id = ? LIMIT 1;
```

#### Bulk insert for MySQL

_Developed by [@Jille](https://github.com/Jille)_

MySQL now supports the `:copyfrom` query annotation. The generated code uses the [LOAD DATA](https://dev.mysql.com/doc/refman/8.0/en/load-data.html) command to insert data quickly and efficiently.

Use caution with this feature. Errors and duplicate keys are treated as warnings and insertion will continue, even without an error for some cases.  Use this in a transaction and use `SHOW WARNINGS` to check for any problems and roll back if necessary.

Check the [error handling](https://dev.mysql.com/doc/refman/8.0/en/load-data.html#load-data-error-handling) documentation for more information.

```sql
CREATE TABLE foo (a text, b integer, c DATETIME, d DATE);

-- name: InsertValues :copyfrom
INSERT INTO foo (a, b, c, d) VALUES (?, ?, ?, ?);
```

```go
func (q *Queries) InsertValues(ctx context.Context, arg []InsertValuesParams) (int64, error) {
	...
}
```

`LOAD DATA` support must be enabled in the MySQL server.

#### CAST support for MySQL

_Developed by [@ryanpbrewster](https://github.com/ryanpbrewster) and [@RadhiFadlillah](https://github.com/RadhiFadlillah)_

`sqlc` now understands `CAST` calls in MySQL queries, offering greater flexibility when generating code for complex queries.

```sql
CREATE TABLE foo (bar BOOLEAN NOT NULL);

-- name: SelectColumnCast :many
SELECT CAST(bar AS BIGINT) FROM foo;
```

```go
package querytest

import (
	"context"
)

const selectColumnCast = `-- name: SelectColumnCast :many
SELECT CAST(bar AS BIGINT) FROM foo
`

func (q *Queries) SelectColumnCast(ctx context.Context) ([]int64, error) {
  ...
}
```

#### SQLite improvements

A slew of fixes landed for our SQLite implementation, bringing it closer to parity with MySQL and PostgreSQL. We want to thank [@orisano](https://github.com/orisano) for their continued dedication to improving `sqlc`'s SQLite support.

### Changes

#### Features

- (debug) Add debug flag and docs for dumping vet rule variables (#2521)
- (mysql) :copyfrom support via LOAD DATA INFILE (#2545)
- (mysql) Implement cast function parser (#2473)
- (postgresql) Add support for PostgreSQL multi-dimensional arrays (#2338)
- (sql/catalog) Support ALTER TABLE IF EXISTS (#2542)
- (sqlite) Virtual tables and fts5 supported (#2531)
- (vet) Add default query parameters for explain queries (#2543)
- (vet) Add output from `EXPLAIN ...` for queries to the CEL program environment (#2489)
- (vet) Introduce a query annotation to opt out of sqlc vet rules (#2474)
- Parse comment lines starting with `@symbol` as boolean flags associated with a query (#2464)

#### Bug Fixes

- (codegen/golang) Fix sqlc.embed to work with pq.Array (#2544)
- (compiler) Correctly validate alias in order/group by clauses for joins (#2537)
- (engine/sqlite) Added function to convert cast node (#2470)
- (engine/sqlite) Fix join_operator rule (#2434)
- (engine/sqlite) Fix table_alias rules (#2465)
- (engine/sqlite) Fixed IN operator precedence (#2428)
- (engine/sqlite) Fixed to be able to find relation from WITH clause (#2444)
- (engine/sqlite) Lowercase ast.ResTarget.Name (#2433)
- (engine/sqlite) Put logging statement behind debug flag (#2488)
- (engine/sqlite) Support for repeated table_option (#2482)
- (mysql) Generate unsigned param (#2522)
- (sql/catalog) Support pg_dump output (#2508)
- (sqlite) Code generation for sqlc.slice (#2431)
- (vet) Clean up unnecessary `prepareable()` func and a var name (#2509)
- (vet) Query.cmd was always set to ":" (#2525)
- (vet) Report an error when a query is unpreparable, close prepared statement connection (#2486)
- (vet) Split vet messages out of codegen.proto (#2511)

#### Documentation

- Add a description to the document for cases when a query result has no rows (#2462)
- Update copyright and author (#2490)
- Add example sqlc.yaml for migration parsing (#2479)
- Small updates (#2506)
- Point GitHub links to new repository location (#2534)

#### Miscellaneous Tasks

- Rename kyleconroy/sqlc to sqlc-dev/sqlc (#2523)
- (proto) Reformat protos using `buf format -w` (#2536)
- Update FEATURE_REQUEST.yml to include SQLite engine option
- Finish migration to sqlc-dev/sqlc (#2548)
- (compiler) Remove some duplicate code (#2546)

#### Testing

- Add profiles to docker compose (#2503)

#### Build

- Run all supported versions of MySQL / PostgreSQL (#2463)
- (deps) Bump pygments from 2.7.4 to 2.15.0 in /docs (#2485)
- (deps) Bump github.com/jackc/pgconn from 1.14.0 to 1.14.1 (#2483)
- (deps) Bump github.com/google/cel-go from 0.16.0 to 0.17.1 (#2484)
- (docs) Check Python dependencies via dependabot (#2497)
- (deps) Bump idna from 2.10 to 3.4 in /docs (#2499)
- (deps) Bump packaging from 20.9 to 23.1 in /docs (#2498)
- (deps) Bump pygments from 2.15.0 to 2.15.1 in /docs (#2500)
- (deps) Bump certifi from 2022.12.7 to 2023.7.22 in /docs (#2504)
- (deps) Bump sphinx from 4.4.0 to 6.1.0 in /docs (#2505)
- Add psql and mysqlsh to devenv (#2507)
- (deps) Bump urllib3 from 1.26.5 to 2.0.4 in /docs (#2516)
- (deps) Bump chardet from 4.0.0 to 5.1.0 in /docs (#2517)
- (deps) Bump snowballstemmer from 2.1.0 to 2.2.0 in /docs (#2519)
- (deps) Bump pytz from 2021.1 to 2023.3 in /docs (#2520)
- (deps) Bump sphinxcontrib-htmlhelp from 2.0.0 to 2.0.1 in /docs (#2518)
- (deps) Bump pyparsing from 2.4.7 to 3.1.0 in /docs (#2530)
- (deps) Bump alabaster from 0.7.12 to 0.7.13 in /docs (#2526)
- (docs) Ignore updates for sphinx (#2532)
- (deps) Bump babel from 2.9.1 to 2.12.1 in /docs (#2527)
- (deps) Bump sphinxcontrib-applehelp from 1.0.2 to 1.0.4 in /docs (#2533)
- (deps) Bump google.golang.org/grpc from 1.56.2 to 1.57.0 (#2535)
- (deps) Bump pyparsing from 3.1.0 to 3.1.1 in /docs (#2547)


## [1.19.1](https://github.com/sqlc-dev/sqlc/releases/tag/v1.19.1)
Released 2023-07-13

### Bug Fixes

- Fix to traverse Sel in ast.In (#2414)
- (compiler) Validate UNION ... ORDER BY (#2446)
- (golang) Prevent duplicate enum output (#2447)

### Miscellaneous Tasks

- Replace codegen, test and docs references to github.com/tabbed repos (#2418)

### Build

- (deps) Bump google.golang.org/grpc from 1.56.1 to 1.56.2 (#2415)
- (deps) Bump golang from 1.20.5 to 1.20.6 (#2437)
- Pin Go to 1.20.6 (#2441)
- (deps) Bump github.com/jackc/pgx/v5 from 5.4.1 to 5.4.2 (#2436)

## [1.19.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.19.0)
Released 2023-07-06

### Release notes

#### sqlc vet

[`sqlc vet`](../howto/vet.md) runs queries through a set of lint rules.

Rules are defined in the `sqlc` [configuration](config.md) file. They consist
of a name, message, and a [Common Expression Language (CEL)](https://github.com/google/cel-spec)
expression. Expressions are evaluated using [cel-go](https://github.com/google/cel-go).
If an expression evaluates to `true`, an error is reported using the given message.

While these examples are simplistic, they give you a flavor of the types of
rules you can write.

```yaml
version: 2
sql:
  - schema: "query.sql"
    queries: "query.sql"
    engine: "postgresql"
    gen:
      go:
        package: "authors"
        out: "db"
    rules:
      - no-pg
      - no-delete
      - only-one-param
      - no-exec
rules:
  - name: no-pg
    message: "invalid engine: postgresql"
    rule: |
      config.engine == "postgresql"
  - name: no-delete
    message: "don't use delete statements"
    rule: |
      query.sql.contains("DELETE")
  - name: only-one-param
    message: "too many parameters"
    rule: |
      query.params.size() > 1
  - name: no-exec
    message: "don't use exec"
    rule: |
      query.cmd == "exec"
```

##### Database connectivity

`vet` also marks the first time that `sqlc` can connect to a live, running
database server. We'll expand this functionality over time, but for now it
powers the `sqlc/db-prepare` built-in rule.

When a [database](config.html#database) is configured, the
`sqlc/db-preapre` rule will attempt to prepare each of your
queries against the connected database and report any failures.

```yaml
version: 2
sql:
  - schema: "query.sql"
    queries: "query.sql"
    engine: "postgresql"
    gen:
      go:
        package: "authors"
        out: "db"
    database:
      uri: "postgresql://postgres:password@localhost:5432/postgres"
    rules:
      - sqlc/db-prepare
```

To see this in action, check out the [authors
example](https://github.com/sqlc-dev/sqlc/blob/main/examples/authors/sqlc.yaml).

Please note that `sqlc` does not manage or migrate your database. Use your
migration tool of choice to create the necessary database tables and objects
before running `sqlc vet`.

#### Omit unused structs

Added a new configuration parameter `omit_unused_structs` which, when set to
true, filters out table and enum structs that aren't used in queries for a given
package.

#### Suggested CI/CD setup

With the addition of `sqlc diff` and `sqlc vet`, we encourage users to run sqlc
in your CI/CD pipelines. See our [suggested CI/CD setup](../howto/ci-cd.md) for
more information.

#### Simplified plugin development

The [sqlc-gen-kotlin](https://github.com/sqlc-dev/sqlc-gen-kotlin) and
[sqlc-gen-python](https://github.com/sqlc-dev/sqlc-gen-python) plugins have been
updated use the upcoming [WASI](https://wasi.dev/) support in [Go
1.21](https://tip.golang.org/doc/go1.21#wasip1). Building these plugins no
longer requires [TinyGo](https://tinygo.org/).

### Changes

#### Bug Fixes

- Pointers overrides skip imports in generated query files (#2240)
- CASE-ELSE clause is not properly parsed when a value is constant (#2238)
- Fix toSnakeCase to handle input in CamelCase format (#2245)
- Add location info to sqlite ast (#2298)
- Add override tags to result struct (#1867) (#1887)
- Override types of aliased columns and named parameters (#1884)
- Resolve duplicate fields generated when inheriting multiple tables (#2089)
- Check column references in ORDER BY (#1411) (#1915)
- MySQL slice shadowing database/sql import (#2332)
- Don't defer rows.Close() if pgx.BatchResults.Query() failed  (#2362)
- Fix type overrides not working with sqlc.slice (#2351)
- Type overrides on columns for parameters inside an IN clause (#2352)
- Broken interaction between query_parameter_limit and pq.Array() (#2383)
- (codegen/golang) Bring :execlastid in line with the rest (#2378)

#### Documentation

- Update changelog.md with some minor edits (#2235)
- Add F# community plugin (#2295)
- Add a ReadTheDocs config file (#2327)
- Update query_parameter_limit documentation (#2374)
- Add launch announcement banner

#### Features
- PostgreSQL capture correct line and column numbers for parse error (#2289)
- Add supporting COMMENT ON VIEW (#2249)
- To allow spaces between function name and arguments of functions to be rewritten (#2250)
- Add support for pgx/v5 emit_pointers_for_null_types flag (#2269)
- (mysql) Support unsigned integers (#1746)
- Allow use of table and column aliases for table functions returning unknown types (#2156)
- Support "LIMIT ?" in UPDATE and DELETE for MySQL (#2365)
- (internal/codegen/golang) Omit unused structs from output (#2369)
- Improve default names for BETWEEN ? AND ? to have prefixes from_ and to_ (#2366)
- (cmd/sqlc) Add the vet subcommand (#2344)
- (sqlite) Add support for UPDATE/DELETE with a LIMIT clause (#2384)
- Add support for BETWEEN sqlc.arg(min) AND sqlc.arg(max) (#2373)
- (cmd/vet) Prepare queries against a database (#2387)
- (cmd/vet) Prepare queries for MySQL (#2388)
- (cmd/vet) Prepare SQLite queries (#2389)
- (cmd/vet) Simplify environment variable substiution (#2393)
- (cmd/vet) Add built-in db-prepare rule
- Add compiler support for NOTIFY and LISTEN (PostgreSQL) (#2363)

#### Miscellaneous Tasks

- A few small staticcheck fixes (#2361)
- Remove a bunch of dead code (#2360)
- (scripts/regenerate) Should also update stderr.txt (#2379)

#### Build

- (deps) Bump requests from 2.25.1 to 2.31.0 in /docs (#2283)
- (deps) Bump golang from 1.20.3 to 1.20.4 (#2256)
- (deps) Bump google.golang.org/grpc from 1.54.0 to 1.55.0 (#2265)
- (deps) Bump github.com/mattn/go-sqlite3 from 1.14.16 to 1.14.17 (#2293)
- (deps) Bump golang.org/x/sync from 0.1.0 to 0.2.0 (#2266)
- (deps) Bump golang from 1.20.4 to 1.20.5 (#2301)
- Configure dependencies via devenv.sh (#2319)
- Configure dependencies via devenv.sh (#2326)
- (deps) Bump golang.org/x/sync from 0.2.0 to 0.3.0 (#2328)
- (deps) Bump google.golang.org/grpc from 1.55.0 to 1.56.0 (#2333)
- (deps) Bump google.golang.org/protobuf from 1.30.0 to 1.31.0 (#2370)
- (deps) Bump actions/checkout from 2 to 3 (#2357)
- Run govulncheck on all builds (#2372)
- (deps) Bump google.golang.org/grpc from 1.56.0 to 1.56.1 (#2358)

#### Cmd/sqlc

- Show helpful output on missing subcommand (#2345)

#### Codegen

- Use catalog's default schema (#2310)
- (go) Add tests for tables with dashes (#2312)
- (go) Strip invalid characters from table and column names (#2314)
- (go) Support JSON tags for nullable enum structs (#2121)

#### Internal/config

- Support golang overrides for slices (#2339)

#### Kotlin

- Use latest version of sqlc-gen-kotlin (#2356)

#### Postgres

- Column merging for table inheritence (#2315)

#### Protos

- Add missing field name (#2354)

#### Python

- Use latest version of sqlc-gen-python (#2355)

#### Remote

- Use user-id/password auth (#2262)

#### Sqlite

- Fixed sqlite column type override (#1986)


## [1.18.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.18.0)
Released 2023-04-27

### Release notes

#### Remote code generation

_Developed by [@andrewmbenton](https://github.com/andrewmbenton)_

At its core, sqlc is powered by SQL engines, which include parsers, formatters,
analyzers and more. While our goal is to support each engine on each operating
system, it's not always possible. For example, the PostgreSQL engine does not
work on Windows.

To bridge that gap, we're announcing remote code generation, currently in
private alpha. To join the private alpha, [sign up for the waitlist](https://docs.google.com/forms/d/e/1FAIpQLScDWrGtTgZWKt3mdlF5R2XCX6tL1pMkB4yuZx5yq684tTNN1Q/viewform?usp=sf_link).

Remote code generation works like local code generation, except the heavy
lifting is performed in a consistent cloud environment. WASM-based plugins are
supported in the remote environment, but process-based plugins are not.

To configure remote generation, add a `cloud` block in `sqlc.json`.

```json
{
  "version": "2",
  "cloud": {
    "organization": "<org-id>",
    "project": "<project-id>",
  },
  ...
}
```

You'll also need to set the `SQLC_AUTH_TOKEN` environment variable.

```bash
export SQLC_AUTH_TOKEN=<token>
```

When the `cloud` configuration block exists, `sqlc generate` will default to remote
code generation. If you'd like to generate code locally without removing the `cloud`
block from your config, pass the `--no-remote` option.


```bash
sqlc generate --no-remote
```

Remote generation is off by default and requires an opt-in to use.

#### sqlc.embed

_Developed by [@nickjackson](https://github.com/nickjackson)_

Embedding allows you to reuse existing model structs in more queries, resulting
in less manual serialization work. First, imagine we have the following schema
with students and test scores.


```sql
CREATE TABLE students (
  id   bigserial PRIMARY KEY,
  name text,
  age  integer
)

CREATE TABLE test_scores (
  student_id bigint,
  score integer,
  grade text
)
```

We want to select the student record and the highest score they got on a test.
Here's how we'd usually do that:

```sql
-- name: HighScore :many
WITH high_scores AS (
  SELECT student_id, max(score) as high_score
  FROM test_scores
  GROUP BY 1
)
SELECT students.*, high_score::integer
FROM students
JOIN high_scores ON high_scores.student_id = students.id;
```

When using Go, sqlc will produce a struct like this:

```
type HighScoreRow struct {
	ID        int64
	Name      sql.NullString
	Age       sql.NullInt32
	HighScore int32
}
```

With embedding, the struct will contain a model for the table instead of a
flattened list of columns.

```sql
-- name: HighScoreEmbed :many
WITH high_scores AS (
  SELECT student_id, max(score) as high_score
  FROM test_scores
  GROUP BY 1
)
SELECT sqlc.embed(students), high_score::integer
FROM students
JOIN high_scores ON high_scores.student_id = students.id;
```

```
type HighScoreRow struct {
	Student   Student
	HighScore int32
}
```

#### sqlc.slice

_Developed by Paul Cameron and Jille Timmermans_

The MySQL Go driver does not support passing slices to the IN operator. The
`sqlc.slice` function generates a dynamic query at runtime with the correct
number of parameters.

```sql
/* name: SelectStudents :many */
SELECT * FROM students 
WHERE age IN (sqlc.slice("ages"))
```

```go
func (q *Queries) SelectStudents(ctx context.Context, ages []int32) ([]Student, error) {
```

This feature is only supported in MySQL and cannot be used with prepared
queries.

#### Batch operation improvements  

When using batches with pgx, the error returned when a batch is closed is
exported by the generated package. This change allows for cleaner error
handling using `errors.Is`.

```go
errors.Is(err, generated_package.ErrBatchAlreadyClosed)
```

Previously, you would have had to check match on the error message itself.

```
err.Error() == "batch already closed"
```

The generated code for batch operations always lived in `batch.go`. This file
name can now be configured via the `output_batch_file_name` configuration
option.

#### Configurable query parameter limits for Go

By default, sqlc will limit Go functions to a single parameter. If a query
includes more than one parameter, the generated method will use an argument
struct instead of positional arguments. This behavior can now be changed via
the `query_parameter_limit` configuration option.  If set to `0`, every
genreated method will use a argument struct. 

### Changes

#### Bug Fixes

- Prevent variable redeclaration in single param conflict for pgx (#2058)
- Retrieve Larg/Rarg join query after inner join (#2051)
- Rename argument when conflicted to imported package (#2048)
- Pgx closed batch return pointer if need #1959 (#1960)
- Correct singularization of "waves" (#2194)
- Honor Package level renames in v2 yaml config (#2001)
- (mysql) Prevent UPDATE ... JOIN panic #1590 (#2154)
- Mysql delete join panic (#2197)
- Missing import with pointer overrides, solves #2168 #2125 (#2217)

#### Documentation

- (config.md) Add `sqlite` as engine option (#2164)
- Add first pass at pgx documentation (#2174)
- Add missed configuration option (#2188)
- `specifies parameter ":one" without containing a RETURNING clause` (#2173)

#### Features

- Add `sqlc.embed` to allow model re-use (#1615)
- (Go) Add query_parameter_limit conf to codegen (#1558)
- Add remote execution for codegen (#2214)

#### Testing

- Skip tests if required plugins are missing (#2104)
- Add tests for reanme fix in v2 (#2196)
- Regenerate batch output for filename tests
- Remove remote test (#2232)
- Regenerate test output

#### Bin/sqlc

- Add SQLCTMPDIR environment variable (#2189)

#### Build

- (deps) Bump github.com/antlr/antlr4/runtime/Go/antlr (#2109)
- (deps) Bump github.com/jackc/pgx/v4 from 4.18.0 to 4.18.1 (#2119)
- (deps) Bump golang from 1.20.1 to 1.20.2 (#2135)
- (deps) Bump google.golang.org/protobuf from 1.28.1 to 1.29.0 (#2137)
- (deps) Bump google.golang.org/protobuf from 1.29.0 to 1.29.1 (#2143)
- (deps) Bump golang from 1.20.2 to 1.20.3 (#2192)
- (deps) Bump actions/setup-go from 3 to 4 (#2150)
- (deps) Bump google.golang.org/protobuf from 1.29.1 to 1.30.0 (#2151)
- (deps) Bump github.com/spf13/cobra from 1.6.1 to 1.7.0 (#2193)
- (deps) Bump github.com/lib/pq from 1.10.7 to 1.10.8 (#2211)
- (deps) Bump github.com/lib/pq from 1.10.8 to 1.10.9 (#2229)
- (deps) Bump github.com/go-sql-driver/mysql from 1.7.0 to 1.7.1 (#2228)

#### Cmd/sqlc

- Remove --experimental flag (#2170)
- Add option to disable process-based plugins (#2180)
- Bump version to v1.18.0

#### Codegen

- Correctly generate CopyFrom columns for single-column copyfroms (#2185)

#### Config

- Add top-level cloud configuration (#2204)

#### Engine/postgres

- Upgrade to pg_query_go/v4 (#2114)

#### Ext/wasm

- Check exit code on returned error (#2223)

#### Parser

- Generate correct types for `SELECT NOT EXISTS` (#1972)

#### Sqlite

- Add support for CREATE TABLE ... STRICT (#2175)

#### Wasm

- Upgrade to wasmtime v8.0.0 (#2222)

## [1.17.2](https://github.com/sqlc-dev/sqlc/releases/tag/v1.17.2)
Released 2023-02-22

### Bug Fixes

- Fix build on Windows (#2102)

## [1.17.1](https://github.com/sqlc-dev/sqlc/releases/tag/v1.17.1)
Released 2023-02-22

### Bug Fixes

- Prefer to use []T over pgype.Array[T] (#2090)
- Revert changes to Dockerfile (#2091)
- Do not throw error when IF NOT EXISTS is used on ADD COLUMN (#2092)

### MySQL

- Add `float` support to MySQL (#2097)

### Build

- (deps) Bump golang from 1.20.0 to 1.20.1 (#2082)

## [1.17.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.17.0)
Released 2023-02-13

### Bug Fixes

- Initialize generated code outside function (#1850)
- (engine/mysql) Take into account column's charset to distinguish text/blob, (var)char/(var)binary (#776) (#1895)
- The enum Value method returns correct type (#1996)
- Documentation for Inserting Rows (#2034)
- Add import statements even if only pointer types exist (#2046)
- Search from Rexpr if not found from Lexpr (#2056)

### Documentation

- Change ENTRYPOINT to CMD (#1943)
- Update samples for HOW-TO GUIDES (#1953)

### Features

- Add the diff command (#1963)

### Build

- (deps) Bump github.com/mattn/go-sqlite3 from 1.14.15 to 1.14.16 (#1913)
- (deps) Bump github.com/spf13/cobra from 1.6.0 to 1.6.1 (#1909)
- Fix devcontainer (#1942)
- Run sqlc-pg-gen via GitHub Actions (#1944)
- Move large arrays out of functions (#1947)
- Fix conflicts from pointer configuration (#1950)
- (deps) Bump github.com/go-sql-driver/mysql from 1.6.0 to 1.7.0 (#1988)
- (deps) Bump github.com/jackc/pgtype from 1.12.0 to 1.13.0 (#1978)
- (deps) Bump golang from 1.19.3 to 1.19.4 (#1992)
- (deps) Bump certifi from 2020.12.5 to 2022.12.7 in /docs (#1993)
- (deps) Bump golang from 1.19.4 to 1.19.5 (#2016)
- (deps) Bump golang from 1.19.5 to 1.20.0 (#2045)
- (deps) Bump github.com/jackc/pgtype from 1.13.0 to 1.14.0 (#2062)
- (deps) Bump github.com/jackc/pgx/v4 from 4.17.2 to 4.18.0 (#2063)

### Cmd

- Generate packages in parallel (#2026)

### Cmd/sqlc

- Bump version to v1.17.0

### Codegen

- Remove built-in Kotlin support (#1935)
- Remove built-in Python support (#1936)

### Internal/codegen

- Cache pattern matching compilations (#2028)

### Mysql

- Add datatype tests (#1948)
- Fix blob tests (#1949)

### Plugins

- Upgrade to wasmtime 3.0.1 (#2009)

### Sqlite

- Supported between expr (#1958) (#1967)

### Tools

- Regenerate scripts skips dirs that contains diff exec command (#1987)

### Wasm

- Upgrade to wasmtime 5.0.0 (#2065)

## [1.16.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.16.0)
Released 2022-11-09


### Bug Fixes

- (validate) Sqlc.arg & sqlc.narg are not "missing" (#1814)
- Emit correct comment for nullable enums (#1819)
- 🐛 Correctly switch `coalesce()` result `.NotNull` value (#1664)
- Prevent batch infinite loop with arg length (#1794)
- Support version 2 in error message (#1839)
- Handle empty column list in postgresql (#1843)
- Batch imports filter queries, update cmds having ret type (#1842)
- Named params contribute to batch parameter count (#1841)

### Documentation

- Add a getting started guide for SQLite (#1798)
- Various readability improvements (#1854)
- Add documentation for codegen plugins (#1904)
- Update migration guides with links (#1933)

### Features

- Add HAVING support to MySQL (#1806)

### Miscellaneous Tasks

- Upgrade wasmtime version (#1827)
- Bump wasmtime version to v1.0.0 (#1869)

### Build

- (deps) Bump github.com/jackc/pgconn from 1.12.1 to 1.13.0 (#1785)
- (deps) Bump github.com/mattn/go-sqlite3 from 1.14.13 to 1.14.15 (#1799)
- (deps) Bump github.com/jackc/pgx/v4 from 4.16.1 to 4.17.0 (#1786)
- (deps) Bump github.com/jackc/pgx/v4 from 4.17.0 to 4.17.1 (#1825)
- (deps) Bump github.com/bytecodealliance/wasmtime-go (#1826)
- (deps) Bump github.com/jackc/pgx/v4 from 4.17.1 to 4.17.2 (#1831)
- (deps) Bump golang from 1.19.0 to 1.19.1 (#1834)
- (deps) Bump github.com/google/go-cmp from 0.5.8 to 0.5.9 (#1838)
- (deps) Bump github.com/lib/pq from 1.10.6 to 1.10.7 (#1835)
- (deps) Bump github.com/bytecodealliance/wasmtime-go (#1857)
- (deps) Bump github.com/spf13/cobra from 1.5.0 to 1.6.0 (#1893)
- (deps) Bump golang from 1.19.1 to 1.19.3 (#1920)

### Cmd/sqlc

- Bump to v1.16.0

### Codgen

- Include serialized codegen options (#1890)

### Compiler

- Move Kotlin parameter logic into codegen (#1910)

### Examples

- Port Python examples to WASM plugin (#1903)

### Pg-gen

- Make sqlc-pg-gen the complete source of truth for pg_catalog.go (#1809)
- Implement information_schema shema (#1815)

### Python

- Port all Python tests to sqlc-gen-python (#1907)
- Upgrade to sqlc-gen-python v1.0.0 (#1932)

## [1.15.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.15.0)
Released 2022-08-07

### Bug Fixes

- (mysql) Typo (#1700)
- (postgresql) Add quotes for CamelCase columns (#1729)
- Cannot parse SQLite upsert statement (#1732)
- (sqlite) Regenerate test output for builtins (#1735)
- (wasm) Version modules by wasmtime version (#1734)
- Missing imports (#1637)
- Missing slice import for querier (#1773)

### Documentation

- Add process-based plugin docs (#1669)
- Add links to downloads.sqlc.dev (#1681)
- Update transactions how to example (#1775)

### Features

- More SQL Syntax Support for SQLite (#1687)
- (sqlite) Promote SQLite support to beta (#1699)
- Codegen plugins, powered by WASM (#1684)
- Set user-agent for plugin downloads (#1707)
- Null enums types (#1485)
- (sqlite) Support stdlib functions (#1712)
- (sqlite) Add support for returning (#1741)

### Miscellaneous Tasks

- Add tests for quoting columns (#1733)
- Remove catalog tests (#1762)

### Testing

- Add tests for fixing slice imports (#1736)
- Add test cases for returning (#1737)

### Build

- Upgrade to Go 1.19 (#1780)
- Upgrade to go-wasmtime 0.39.0 (#1781)

### Plugins

- (wasm) Change default cache location (#1709)
- (wasm) Change the SHA-256 config key (#1710)

## [1.14.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.14.0)
Released 2022-06-09

### Bug Fixes

- (postgresql) Remove extra newline with db argument (#1417)
- (sqlite) Fix DROP TABLE   (#1443)
- (compiler) Fix left join nullability with table aliases (#1491)
- Regenerate testdata for CREATE TABLE AS (#1516)
- (bundler) Only close multipart writer once (#1528)
- (endtoend) Regenerate testdata for exex_lastid
- (pgx) Copyfrom imports (#1626)
- Validate sqlc function arguments (#1633)
- Fixed typo `sql.narg` in doc (#1668)

### Features

- (golang) Add Enum.Valid and AllEnumValues (#1613)
- (sqlite) Start expanding support (#1410)
- (pgx) Add support for batch operations (#1437)
- (sqlite) Add support for delete statements (#1447)
- (codegen) Insert comments in interfaces (#1458)
- (sdk) Add the plugin SDK package (#1463)
- Upload projects (#1436)
- Add sqlc version to generated Kotlin code (#1512)
- Add sqlc version to generated Go code (#1513)
- Pass sqlc version in codegen request (#1514)
- (postgresql) Add materialized view support (#1509)
- (python) Graduate Python support to beta (#1520)
- Run sqlc with docker on windows cmd (#1557)
- Add JSON "codegen" output (#1565)
- Add sqlc.narg() for nullable named params (#1536)
- Process-based codegen plugins (#1578)

### Miscellaneous Tasks

- Fix extra newline in comments for copyfrom (#1438)
- Generate marshal/unmarshal with vtprotobuf (#1467)

### Refactor

- (codegen) Port Kotlin codegen package to use plugin types (#1416)
- (codegen) Port Go to plugin types (#1460)
- (cmd) Simplify codegen selection logic (#1466)
- (sql/catalog) Improve Readability (#1595)
- Add basic fuzzing for config / overrides (#1500)

## [1.13.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.13.0)
Released 2022-03-31

### Bug Fixes

- (compiler) Fix left join nullability with table aliases (#1491)
- (postgresql) Remove extra newline with db argument (#1417)
- (sqlite) Fix DROP TABLE (#1443)

### Features

- (cli) Upload projects (#1436)
- (codegen) Add sqlc version to generated Go code (#1513)
- (codegen) Add sqlc version to generated Kotlin code (#1512)
- (codegen) Insert comments in interfaces (#1458)
- (codegen) Pass sqlc version in codegen request (#1514)
- (pgx) Add support for batch operations (#1437)
- (postgresql) Add materialized view support (#1509)
- (python) Graduate Python support to beta (#1520)
- (sdk) Add the plugin SDK package (#1463)
- (sqlite) Add support for delete statements (#1447)
- (sqlite) Start expanding support (#1410)

### Miscellaneous Tasks

- Fix extra newline in comments for copyfrom (#1438)
- Generate marshal/unmarshal with vtprotobuf (#1467)

### Refactor

- (codegen) Port Kotlin codegen package to use plugin types (#1416)
- (codegen) Port Go to plugin types (#1460)
- (cmd) Simplify codegen selection logic (#1466)

### Config

- Add basic fuzzing for config / overrides (#1500)

## [1.12.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.12.0)
Released 2022-02-05

### Bug

- ALTER TABLE SET SCHEMA (#1409)

### Bug Fixes

- Update ANTLR v4 go.mod entry (#1336)
- Check delete statements for CTEs (#1329)
- Fix validation of GROUP BY on field aliases (#1348)
- Fix imports when non-copyfrom queries needed imports that copyfrom queries didn't (#1386)
- Remove extra comment newline (#1395)
- Enable strict function checking (#1405)

### Documentation

- Bump version to 1.11.0 (#1308)

### Features

- Inheritance (#1339)
- Generate query code using ASTs instead of templates (#1338)
- Add support for CREATE TABLE a ( LIKE b ) (#1355)
- Add support for sql.NullInt16 (#1376)

### Miscellaneous Tasks

- Add tests for :exec{result,rows} (#1344)
- Delete template-based codegen (#1345)

### Build

- Bump github.com/jackc/pgx/v4 from 4.14.0 to 4.14.1 (#1316)
- Bump golang from 1.17.3 to 1.17.4 (#1331)
- Bump golang from 1.17.4 to 1.17.5 (#1337)
- Bump github.com/spf13/cobra from 1.2.1 to 1.3.0 (#1343)
- Remove devel Docker build
- Bump golang from 1.17.5 to 1.17.6 (#1369)
- Bump github.com/google/go-cmp from 0.5.6 to 0.5.7 (#1382)
- Format all Go code (#1387)

## [1.11.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.11.0)
Released 2021-11-24


### Bug Fixes

- Update incorrect signatures (#1180)
- Correct aggregate func sig (#1182)
- Jsonb_build_object (#1211)
- Case-insensitive identifiers (#1216)
- Incorrect handling of meta (#1228)
- Detect invalid INSERT expression (#1231)
- Respect alias name for coalesce (#1232)
- Mark nullable when casting NULL (#1233)
- Support nullable fields in joins for MySQL engine (#1249)
- Fix between expression handling of table references (#1268)
- Support nullable fields in joins on same table (#1270)
- Fix missing binds in ORDER BY (#1273)
- Set RV for TargetList items on updates (#1252)
- Fix MySQL parser for query without trailing semicolon (#1282)
- Validate table alias references (#1283)
- Add support for MySQL ON DUPLICATE KEY UPDATE (#1286)
- Support references to columns in joined tables in UPDATE statements (#1289)
- Add validation for GROUP BY clause column references (#1285)
- Prevent variable redeclaration in single param conflict (#1298)
- Use common params struct field for same named params (#1296)

### Documentation

- Replace deprecated go get with go install (#1181)
- Fix package name referenced in tutorial (#1202)
- Add environment variables (#1264)
- Add go.17+ install instructions (#1280)
- Warn about golang-migrate file order (#1302)

### Features

- Instrument compiler via runtime/trace (#1258)
- Add MySQL support for BETWEEN arguments (#1265)

### Refactor

- Move from io/ioutil to io and os package (#1164)

### Styling

- Apply gofmt to sample code (#1261)

### Build

- Bump golang from 1.17.0 to 1.17.1 (#1173)
- Bump eskatos/gradle-command-action from 1 to 2 (#1220)
- Bump golang from 1.17.1 to 1.17.2 (#1227)
- Bump github.com/pganalyze/pg_query_go/v2 (#1234)
- Bump actions/checkout from 2.3.4 to 2.3.5 (#1238)
- Bump babel from 2.9.0 to 2.9.1 in /docs (#1245)
- Bump golang from 1.17.2 to 1.17.3 (#1272)
- Bump actions/checkout from 2.3.5 to 2.4.0 (#1267)
- Bump github.com/lib/pq from 1.10.3 to 1.10.4 (#1278)
- Bump github.com/jackc/pgx/v4 from 4.13.0 to 4.14.0 (#1303)

### Cmd/sqlc

- Bump version to v1.11.0

## [1.10.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.10.0)
Released 2021-09-07


### Documentation

- Fix invalid language support table (#1161)
- Add a getting started guide for MySQL (#1163)

### Build

- Bump golang from 1.16.7 to 1.17.0 (#1129)
- Bump github.com/lib/pq from 1.10.2 to 1.10.3 (#1160)

### Ci

- Upgrade Go to 1.17 (#1130)

### Cmd/sqlc

- Bump version to v1.10.0 (#1165)

### Codegen/golang

- Consolidate import logic (#1139)
- Add pgx support for range types (#1146)
- Use pgtype for hstore when using pgx (#1156)

### Codgen/golang

- Use p[gq]type for network address types (#1142)

### Endtoend

- Run `go test` in CI (#1134)

### Engine/mysql

- Add support for LIKE (#1162)

### Golang

- Output NullUUID when necessary (#1137)

## [1.9.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.9.0)
Released 2021-08-13


### Documentation

- Update documentation (a bit) for v1.9.0 (#1117)

### Build

- Bump golang from 1.16.6 to 1.16.7 (#1107)

### Cmd/sqlc

- Bump version to v1.9.0 (#1121)

### Compiler

- Add tests for COALESCE behavior (#1112)
- Handle subqueries in SELECT statements (#1113)

## [1.8.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.8.0)
Released 2021-05-03


### Documentation

- Add language support Matrix (#920)

### Features

- Add case style config option (#905)

### Python

- Eliminate runtime package and use sqlalchemy (#939)

### Build

- Bump github.com/google/go-cmp from 0.5.4 to 0.5.5 (#926)
- Bump github.com/lib/pq from 1.9.0 to 1.10.0 (#931)
- Bump golang from 1.16.0 to 1.16.1 (#935)
- Bump golang from 1.16.1 to 1.16.2 (#942)
- Bump github.com/jackc/pgx/v4 from 4.10.1 to 4.11.0 (#956)
- Bump github.com/go-sql-driver/mysql from 1.5.0 to 1.6.0 (#961)
- Bump github.com/pganalyze/pg_query_go/v2 (#965)
- Bump urllib3 from 1.26.3 to 1.26.4 in /docs (#968)
- Bump golang from 1.16.2 to 1.16.3 (#963)
- Bump github.com/lib/pq from 1.10.0 to 1.10.1 (#980)

### Cmd

- Add the --experimental flag (#929)
- Fix sqlc init (#959)

### Cmd/sqlc

- Bump version to v1.7.1-devel (#913)
- Bump version to v1.8.0

### Codegen

- Generate valid enum names for symbols (#972)

### Postgresql

- Support generated columns
- Add test for PRIMARY KEY INCLUDE
- Add tests for CREATE TABLE PARTITION OF
- CREATE TRIGGER EXECUTE FUNCTION
- Add support for renaming types (#971)

### Sql/ast

- Resolve return values from functions (#964)

### Workflows

- Only run tests once (#924)

## [1.7.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.7.0)
Released 2021-02-28


### Bug Fixes

- Struct tag formatting (#833)

### Documentation

- Include all the existing Markdown files (#877)
- Split docs into four sections (#882)
- Reorganize and consolidate documentation
- Add link to Windows download (#888)
- Shorten the README (#889)

### Features

- Adding support for pgx/v4
- Adding support for pgx/v4

### README

- Add Go Report Card badge (#891)

### Build

- Bump github.com/google/go-cmp from 0.5.3 to 0.5.4 (#813)
- Bump github.com/lib/pq from 1.8.0 to 1.9.0 (#820)
- Bump golang from 1.15.5 to 1.15.6 (#822)
- Bump github.com/jackc/pgx/v4 from 4.9.2 to 4.10.0 (#823)
- Bump github.com/jackc/pgx/v4 from 4.10.0 to 4.10.1 (#839)
- Bump golang from 1.15.6 to 1.15.7 (#855)
- Bump golang from 1.15.7 to 1.15.8 (#881)
- Bump github.com/spf13/cobra from 1.1.1 to 1.1.2 (#892)
- Bump golang from 1.15.8 to 1.16.0 (#897)
- Bump github.com/lfittl/pg_query_go from 1.0.1 to 1.0.2 (#901)
- Bump github.com/spf13/cobra from 1.1.2 to 1.1.3 (#893)

### Catalog

- Improve alter column type (#818)

### Ci

- Uprade to Go 1.15 (#887)

### Cmd

- Allow config file location to be specified (#863)

### Cmd/sqlc

- Bump to version v1.6.1-devel (#807)
- Bump version to v1.7.0 (#912)

### Codegen/golang

- Make sure to import net package (#858)

### Compiler

- Support UNION query

### Dolphin

- Generate bools for tinyint(1)
- Support joins in update statements (#883)
- Add support for union query

### Endtoend

- Add tests for INTERSECT and EXCEPT

### Go.mod

- Update to go 1.15 and run 'go mod tidy' (#808)

### Mysql

- Compile tinyint(1) to bool (#873)

### Sql/ast

- Add enum values for SetOperation

## [1.6.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.6.0)
Released 2020-11-23


### Dolphin

- Implement Rename (#651)
- Skip processing view drops (#653)

### README

- Update language / database support (#698)

### Astutils

- Fix Params rewrite call (#674)

### Build

- Bump golang from 1.14 to 1.15.3 (#765)
- Bump docker/build-push-action from v1 to v2.1.0 (#764)
- Bump github.com/google/go-cmp from 0.4.0 to 0.5.2 (#766)
- Bump github.com/spf13/cobra from 1.0.0 to 1.1.1 (#767)
- Bump github.com/jackc/pgx/v4 from 4.6.0 to 4.9.2 (#768)
- Bump github.com/lfittl/pg_query_go from 1.0.0 to 1.0.1 (#773)
- Bump github.com/google/go-cmp from 0.5.2 to 0.5.3 (#783)
- Bump golang from 1.15.3 to 1.15.5 (#782)
- Bump github.com/lib/pq from 1.4.0 to 1.8.0 (#769)

### Catalog

- Improve variadic argument support (#804)

### Cmd/sqlc

- Bump to version v1.6.0 (#806)

### Codegen

- Fix errant database/sql imports (#789)

### Compiler

- Use engine-specific reserved keywords (#677)

### Dolphi

- Add list of builtin functions (#795)

### Dolphin

- Update to the latest MySQL parser (#665)
- Add ENUM() support (#676)
- Add test for table aliasing (#684)
- Add MySQL ddl_create_table test (#685)
- Implete TRUNCATE table (#697)
- Represent tinyint as int32 (#797)
- Add support for coalesce (#802)
- Add function signatures (#796)

### Endtoend

- Add MySQL json test (#692)
- Add MySQL update set multiple test (#696)

### Examples

- Use generated enum constants in db_test (#678)
- Port ondeck to MySQL (#680)
- Add MySQL authors example (#682)

### Internal/cmd

- Print correct config file on parse failure (#749)

### Kotlin

- Remove runtime dependency (#774)

### Metadata

- Support multiple comment prefixes (#683)

### Postgresql

- Support string concat operator (#701)

### Sql/catalog

- Add support for variadic functions (#798)

## [1.5.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.5.0)
Released 2020-08-05


### Documentation

- Build sqlc using Go 1.14 (#549)

### Cmd

- Add debugging support (#573)

### Cmd/sqlc

- Bump version to v1.4.1-devel (#548)
- Bump version to v1.5.0

### Compiler

- Support calling functions with defaults (#635)
- Skip func args without a paramRef (#636)
- Return a single column from coalesce (#639)

### Config

- Add emit_empty_slices to version one (#552)

### Contrib

- Add generated code for contrib

### Dinosql

- Remove deprecated package (#554)

### Dolphin

- Add support for column aliasing (#566)
- Implement star expansion for subqueries (#619)
- Implement exapansion with reserved words (#620)
- Implement parameter refs (#621)
- Implement limit and offest (#622)
- Implement inserts (#623)
- Implement delete (#624)
- Implement simple update statements (#625)
- Implement INSERT ... SELECT (#626)
- Use test driver instead of TiDB driver (#629)
- Implement named parameters via sqlc.arg() (#632)

### Endtoend

- Add MySQL test for SELECT * JOIN (#565)
- Add MySQL test for inflection (#567)

### Engine

- Create engine package (#556)

### Equinox

- Use the new equinox-io/setup action (#586)

### Examples

- Run tests for MySQL booktest (#627)

### Golang

- Add support for the money type (#561)
- Generate correct types for int2 and int8 (#579)

### Internal

- Rm catalog, pg, postgres packages (#555)

### Mod

- Downgrade TiDB package to fix build (#603)

### Mysql

- Upgrade to the latest vitess commit (#562)
- Support to infer type of a duplicated arg (#615)
- Allow some builtin functions to be nullable (#616)

### Postgresql

- Generate all functions in pg_catalog (#550)
- Remove pg_catalog schema from tests (#638)
- Move contrib code to a package

### Sql/catalog

- Fix comparison of pg_catalog types (#637)

### Tools

- Generate functions for all of contrib

### Workflow

- Migrate to equinox-io/setup-release-tool (#614)

## [1.4.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.4.0)
Released 2020-06-17


### Dockerfile

- Add version build argument (#487)

### MySQL

- Prevent Panic when WHERE clause contains parenthesis.  (#531)

### README

- Document emit_exact_table_names (#486)

### All

- Remove the exp build tag (#507)

### Catalog

- Support functions with table parameters (#541)

### Cmd

- Bump to version 1.3.1-devel (#485)

### Cmd/sqlc

- Bump version to v1.4.0 (#547)

### Codegen

- Add the new codegen packages (#513)
- Add the :execresult query annotation (#542)

### Compiler

- Validate function calls (#505)
- Port bottom of parseQuery (#510)
- Don't mutate table name (#517)
- Enable experimental parser by default (#518)
- Apply rename rules to enum constants (#523)
- Temp fix for typecast function parameters (#530)

### Endtoend

- Standardize JSON formatting (#490)
- Add per-test configuration files (#521)
- Read expected stderr failures from disk (#527)

### Internal/dinosql

- Check parameter style before ref (#488)
- Remove unneeded column suffix (#492)
- Support named function arguments (#494)

### Internal/postgresql

- Fix NamedArgExpr rewrite (#491)

### Multierr

- Move dinosql.ParserErr to a new package (#496)

### Named

- Port parameter style validation to SQL (#504)

### Parser

- Support columns from subselect statements (#489)

### Rewrite

- Move parameter rewrite to package (#499)

### Sqlite

- Use convert functions instead of the listener (#519)

### Sqlpath

- Move ReadSQLFiles into a separate package (#495)

### Validation

- Move query validation to separate package (#498)

## [1.3.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.3.0)
Released 2020-05-12


### Makefile

- Update target (#449)

### README

- Add Myles as a sponsor (#469)

### Testing

- Make sure all Go examples build (#480)

### Cmd

- Bump version to v1.3.0 (#484)

### Cmd/sqlc

- Bump version to v1.2.1-devel (#442)

### Dinosql

- Inline addFile (#446)
- Add PostgreSQL support for TRUNCATE (#448)

### Gen

- Emit json.RawMessage for JSON columns (#461)

### Go.mod

- Use latest lib/pq (#471)

### Parser

- Use same function to load SQL files (#483)

### Postgresql

- Fix panic walking CreateTableAsStmt (#475)

## [1.2.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.2.0)
Released 2020-04-07


### Documentation

- Publish to Docker Hub (#422)

### README

- Docker installation docs (#424)

### Cmd/sqlc

- Bump version to v1.1.1-devel (#407)
- Bump version to v1.2.0 (#441)

### Gen

- Add special case for "campus" (#435)
- Properly quote reserved keywords on expansion (#436)

### Migrations

- Move migration parsing to new package (#427)

### Parser

- Generate correct types for SELECT EXISTS (#411)

## [1.1.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.1.0)
Released 2020-03-17


### README

- Add installation instructions (#350)
- Add section on running tests (#357)
- Fix typo (#371)

### Ast

- Add AST for ALTER TABLE ADD / DROP COLUMN (#376)
- Add support for CREATE TYPE as ENUM (#388)
- Add support for CREATE / DROP SCHEMA (#389)

### Astutils

- Apply changes to the ValuesList slice (#372)

### Cmd

- Return v1.0.0 (#348)
- Return next bug fix version (#349)

### Cmd/sqlc

- Bump version to v1.1.0 (#406)

### Compiler

- Wire up the experimental parsers

### Config

- Remove "emit_single_file" option (#367)

### Dolphin

- Add experimental parser for MySQL

### Gen

- Add option to emit single file for Go (#366)
- Add support for the ltree extension (#385)

### Go.mod

- Add packages for MySQL and SQLite parsers

### Internal/dinosql

- Support Postgres macaddr type in Go (#358)

### Internal/endtoend

- Remove %w (#354)

### Kotlin

- Add Query class to support timeout and cancellation (#368)

### Postgresql

- Add experimental parser for MySQL

### Sql

- Add generic SQL AST

### Sql/ast

- Port support for COMMENT ON (#391)
- Implement DROP TYPE (#397)
- Implement ALTER TABLE RENAME (#398)
- Implement ALTER TABLE RENAME column (#399)
- Implement ALTER TABLE SET SCHEMA (#400)

### Sql/catalog

- Port tests over from catalog pkg (#402)

### Sql/errors

- Add a new errors package (#390)

### Sqlite

- Add experimental parser for SQLite

## [1.0.0](https://github.com/sqlc-dev/sqlc/releases/tag/v1.0.0)
Released 2020-02-18


### Documentation

- Add documentation for query commands (#270)
- Add named parameter documentation (#332)

### README

- Add sponsors section (#333)

### Cmd

- Remove parse subcommand (#322)

### Config

- Parse V2 config format
- Add support for YAML (#336)

### Examples

- Add the jets and booktest examples (#237)
- Move sqlc.json into examples folder (#238)
- Add the authors example (#241)
- Add build tag to authors tests (#319)

### Internal

- Allow CTE to be used with UPDATE (#268)
- Remove the PackageMap from settings (#295)

### Internal/config

- Create new config package (#313)

### Internal/dinosql

- Emit Querier interface (#240)
- Strip leading "go-" or trailing "-go" from import (#262)
- Overrides can now be basic types (#271)
- Import needed types for Querier (#285)
- Handle schema-scoped enums (#310)
- Ignore golang-migrate rollbacks (#320)

### Internal/endtoend

- Move more tests to the record/replay framework
- Add update test for named params (#329)

### Internal/mysql

- Fix flaky test (#242)
- Port tests to endtoend package (#315)

### Internal/parser

- Resolve nested CTEs (#324)
- Error if last query is missing (#325)
- Support joins with aliases (#326)
- Remove print statement (#327)

### Internal/sqlc

- Add support for composite types (#311)

### Kotlin

- Support primitives
- Arrays, enums, and dates
- Generate examples
- README for examples
- Factor out db setup extension
- Fix enums, use List instead of Array
- Port Go tests for examples
- Rewrite numbered params to positional params
- Always use use, fix indents
- Unbox query params

### Parser

- Attach range vars to insert params
- Attach range vars to insert params (#342)
- Remove dead code (#343)

## [0.1.0](https://github.com/sqlc-dev/sqlc/releases/tag/v0.1.0)
Released 2020-01-07


### Documentation

- Replace remaining references to DinoSQL with sqlc (#149)

### README

- Fix download links (#66)
- Add LIMIT 1 to query that should return one (#99)

### Catalog

- Support "ALTER TABLE ... DROP CONSTRAINT ..." (#34)
- Differentiate functions with different argument types (#51)

### Ci

- Enable tests on pull requests

### Cmd

- Include filenames in error messages (#69)
- Do not output any changes on error (#72)

### Dinosql/internal

- Add lower and upper functions (#215)
- Ignore alter sequence commands (#219)

### Gen

- Add DO NOT EDIT comments to generated code (#50)
- Include all schemas when generating models (#90)
- Prefix structs with schema name (#91)
- Generate single import for uuid package (#98)
- Use same import logic for all Go files
- Pick correct struct to return for queries (#107)
- Create consistent JSON tags (#110)
- Add Close method to Queries struct (#127)
- Ignore empty override settings (#128)
- Turn SQL comments into Go comments (#136)

### Internal/catalog

- Parse unnamed function arguments (#166)

### Internal/dinosql

- Prepare() with no GoQueries still valid (#95)
- Fix multiline comment rendering (#142)
- Dereference alias nodes on walk (#158)
- Ignore sql-migrate rollbacks (#160)
- Sort imported packages (#165)
- Add support for timestamptz (#169)
- Error on missing queries (#180)
- Use more database/sql null types (#182)
- Support the pg_temp schema (#183)
- Override columns with array type (#184)
- Implement robust expansion
- Implement robust expansion (#186)
- Add COMMENT ON support (#191)
- Add DATE support
- Add DATE support (#196)
- Filter out invalid characters (#198)
- Quote reserved keywords (#205)
- Return parser errors first (#207)
- Implement advisory locks (#212)
- Error on duplicate query names (#221)
- Fix incorrect enum names (#223)
- Add support for numeric types
- Add support for numeric types (#228)

### Internal/dinosql/testdata/ondeck

- Add Makefile (#156)

### Ondeck

- Move all tests to GitHub CI (#58)

### ParseQuery

- Return either a query or an error (#178)

### Parser

- Use schema when resolving catalog refs (#82)
- Support function calls in expressions (#104)
- Correctly handle single files (#119)
- Return error if missing RETURNING (#131)
- Add support for mathmatical operators (#132)
- Add support for simple case expressions (#134)
- Error on mismatched INSERT input (#135)
- Set IsArray on joined columns (#139)

### Pg

- Store functions in the catalog (#41)
- Add location to errors (#73)

<!-- generated by git-cliff -->

================
File: docs/reference/cli.md
================
# CLI

```sh
Usage:
  sqlc [command]

Available Commands:
  compile     Statically check SQL for syntax and type errors
  completion  Generate the autocompletion script for the specified shell
  createdb    Create an ephemeral database
  diff        Compare the generated files to the existing files
  generate    Generate source code from SQL
  help        Help about any command
  init        Create an empty sqlc.yaml settings file
  push        Push the schema, queries, and configuration for this project
  verify      Verify schema, queries, and configuration for this project
  version     Print the sqlc version number
  vet         Vet examines queries

Flags:
  -f, --file string    specify an alternate config file (default: sqlc.yaml)
  -h, --help           help for sqlc
      --no-database    disable database connections (default: false)
      --no-remote      disable remote execution (default: false)

Use "sqlc [command] --help" for more information about a command.
```

================
File: docs/reference/config.md
================
# Configuration

The `sqlc` tool is configured via a `sqlc.(yaml|yml)` or `sqlc.json` file. This
file must be in the directory where the `sqlc` command is run.

## Version 2

```yaml
version: "2"
cloud:
  project: "<PROJECT_ID>"
sql:
- schema: "postgresql/schema.sql"
  queries: "postgresql/query.sql"
  engine: "postgresql"
  gen:
    go: 
      package: "authors"
      out: "postgresql"
  database:
    managed: true
  rules:
    - sqlc/db-prepare
- schema: "mysql/schema.sql"
  queries: "mysql/query.sql"
  engine: "mysql"
  gen:
    go:
      package: "authors"
      out: "mysql"
```

### sql

Each mapping in the `sql` collection has the following keys:

- `name`:
  - An human-friendly identifier for this query set. Optional.
- `engine`:
  - One of `postgresql`, `mysql` or `sqlite`.
- `schema`:
  - Directory of SQL migrations or path to single SQL file; or a list of paths.
- `queries`:
  - Directory of SQL queries or path to single SQL file; or a list of paths.
- `codegen`:
  - A collection of mappings to configure code generators. See [codegen](#codegen) for the supported keys.
- `gen`:
  - A mapping to configure built-in code generators. See [gen](#gen) for the supported keys.
- `database`:
  - A mapping to configure database connections. See [database](#database) for the supported keys.
- `rules`:
  - A collection of rule names to run via `sqlc vet`. See [rules](#rules) for configuration options.
- `analyzer`:
  - A mapping to configure query analysis. See [analyzer](#analyzer) for the supported keys.
- `strict_function_checks`
  - If true, return an error if a called SQL function does not exist. Defaults to `false`.
- `strict_order_by`
  - If true, return an error if a order by column is ambiguous. Defaults to `true`.

### codegen

The `codegen` mapping supports the following keys:

- `out`:
  - Output directory for generated code.
- `plugin`:
  - The name of the plugin. Must be defined in the `plugins` collection.
- `options`:
  - A mapping of plugin-specific options.

```yaml
version: '2'
plugins:
- name: py
  wasm:
    url: https://github.com/sqlc-dev/sqlc-gen-python/releases/download/v0.16.0-alpha/sqlc-gen-python.wasm
    sha256: 428476c7408fd4c032da4ec74e8a7344f4fa75e0f98a5a3302f238283b9b95f2
sql:
- schema: "schema.sql"
  queries: "query.sql"
  engine: postgresql
  codegen:
  - out: src/authors
    plugin: py
    options:
      package: authors
      emit_sync_querier: true
      emit_async_querier: true
      query_parameter_limit: 5
```

### database

The `database` mapping supports the following keys:

- `managed`:
  - If true, connect to a [managed database](../howto/managed-databases.md). Defaults to `false`.
- `uri`:
  - Database connection URI

The `uri` string can contain references to environment variables using the `${...}`
syntax. In the following example, the connection string will have the value of
the `PG_PASSWORD` environment variable set as its password.

```yaml
version: '2'
sql:
- schema: schema.sql
  queries: query.sql
  engine: postgresql
  database:
    uri: postgresql://postgres:${PG_PASSWORD}@localhost:5432/authors
  gen:
    go:
      package: authors
      out: postgresql
```

### analyzer

The `analyzer` mapping supports the following keys:

- `database`:
  -  If false, do not use the configured database for query analysis. Defaults to `true`.
  
### gen

The `gen` mapping supports the following keys:

#### go

- `package`:
  - The package name to use for the generated code. Defaults to `out` basename.
- `out`:
  - Output directory for generated code.
- `sql_package`:
  - Either `pgx/v4`, `pgx/v5` or `database/sql`. Defaults to `database/sql`.
- `sql_driver`:
  - Either `github.com/jackc/pgx/v4`, `github.com/jackc/pgx/v5`, `github.com/lib/pq` or `github.com/go-sql-driver/mysql`. No defaults. Required if query annotation `:copyfrom` is used.
- `emit_db_tags`:
  - If true, add DB tags to generated structs. Defaults to `false`.
- `emit_prepared_queries`:
  - If true, include support for prepared queries. Defaults to `false`.
- `emit_interface`:
  - If true, output a `Querier` interface in the generated package. Defaults to `false`.
- `emit_exact_table_names`:
  - If true, struct names will mirror table names. Otherwise, sqlc attempts to singularize plural table names. Defaults to `false`.
- `emit_empty_slices`:
  - If true, slices returned by `:many` queries will be empty instead of `nil`. Defaults to `false`.
- `emit_exported_queries`:
  - If true, autogenerated SQL statement can be exported to be accessed by another package.
- `emit_json_tags`:
  - If true, add JSON tags to generated structs. Defaults to `false`.
- `emit_result_struct_pointers`:
  - If true, query results are returned as pointers to structs. Queries returning multiple results are returned as slices of pointers. Defaults to `false`.
- `emit_params_struct_pointers`:
  - If true, parameters are passed as pointers to structs. Defaults to `false`.
- `emit_methods_with_db_argument`:
  - If true, generated methods will accept a DBTX argument instead of storing a DBTX on the `*Queries` struct. Defaults to `false`.
- `emit_pointers_for_null_types`:
  - If true, generated types for nullable columns are emitted as pointers (ie. `*string`) instead of `database/sql` null types (ie. `NullString`). Currently only supported for PostgreSQL if `sql_package` is `pgx/v4` or `pgx/v5`, and for SQLite. Defaults to `false`.
- `emit_enum_valid_method`:
  - If true, generate a Valid method on enum types,
    indicating whether a string is a valid enum value.
- `emit_all_enum_values`:
  - If true, emit a function per enum type
    that returns all valid enum values.
- `emit_sql_as_comment`:
  - If true, emits the SQL statement as a code-block comment above the generated function, appending to any existing comments. Defaults to `false`.
- `build_tags`:
  - If set, add a `//go:build <build_tags>` directive at the beginning of each generated Go file.
- `initialisms`:
  - An array of [initialisms](https://google.github.io/styleguide/go/decisions.html#initialisms) to upper-case. For example, `app_id` becomes `AppID`. Defaults to `["id"]`.
- `json_tags_id_uppercase`:
  - If true, "Id" in json tags will be uppercase. If false, will be camelcase. Defaults to `false`
- `json_tags_case_style`:
  - `camel` for camelCase, `pascal` for PascalCase, `snake` for snake_case or `none` to use the column name in the DB. Defaults to `none`.
- `omit_unused_structs`:
  - If `true`, sqlc won't generate table and enum structs that aren't used in queries for a given package. Defaults to `false`.
- `output_batch_file_name`:
  - Customize the name of the batch file. Defaults to `batch.go`.
- `output_db_file_name`:
  - Customize the name of the db file. Defaults to `db.go`.
- `output_models_file_name`:
  - Customize the name of the models file. Defaults to `models.go`.
- `output_querier_file_name`:
  - Customize the name of the querier file. Defaults to `querier.go`.
- `output_copyfrom_file_name`:
  - Customize the name of the copyfrom file. Defaults to `copyfrom.go`.
- `output_files_suffix`:
  - If specified the suffix will be added to the name of the generated files.
- `query_parameter_limit`:
  - The number of positional arguments that will be generated for Go functions. To always emit a parameter struct, set this to `0`. Defaults to `1`.
- `rename`:
  - Customize the name of generated struct fields. See [Renaming fields](../howto/rename.md) for usage information.
- `overrides`:
  - It is a collection of definitions that dictates which types are used to map a database types.

##### overrides

See [Overriding types](../howto/overrides.md) for an in-depth guide to using type overrides. Each mapping of the `overrides` collection has the following keys:

- `db_type`:
  - The PostgreSQL or MySQL type to override. Find the full list of supported types in [postgresql_type.go](https://github.com/sqlc-dev/sqlc/blob/main/internal/codegen/golang/postgresql_type.go#L12) or [mysql_type.go](https://github.com/sqlc-dev/sqlc/blob/main/internal/codegen/golang/mysql_type.go#L12). Note that for Postgres you must use the pg_catalog prefixed names where available. Can't be used if the `column` key is defined.
- `column`:
  - In case the type overriding should be done on specific a column of a table instead of a type. `column` should be of the form `table.column` but you can be even more specific by specifying `schema.table.column` or `catalog.schema.table.column`. Can't be used if the `db_type` key is defined.
- `go_type`:
  - A fully qualified name to a Go type to use in the generated code.
- `go_struct_tag`:
  - A reflect-style struct tag to use in the generated code, e.g. `a:"b" x:"y,z"`.
    If you want general json/db tags for all fields, use `emit_db_tags` and/or `emit_json_tags` instead.
- `nullable`:
  - If `true`, use this type when a column is nullable. Defaults to `false`.

For more complicated import paths, the `go_type` can also be an object with the following keys:

- `import`:
  - The import path for the package where the type is defined.
- `package`:
  - The package name where the type is defined. This should only be necessary when your import path doesn't end with the desired package name.
- `type`:
  - The type name itself, without any package prefix.
- `pointer`:
  - If set to `true`, generated code will use pointers to the type rather than the type itself.
- `slice`:
  - If set to `true`, generated code will use a slice of the type rather than the type itself.

#### kotlin

> Removed in v1.17.0 and replaced by the [sqlc-gen-kotlin](https://github.com/sqlc-dev/sqlc-gen-kotlin) plugin. Follow the [migration guide](../guides/migrating-to-sqlc-gen-kotlin) to switch.

- `package`:
  - The package name to use for the generated code.
- `out`:
  - Output directory for generated code.
- `emit_exact_table_names`:
  - If true, use the exact table name for generated models. Otherwise, guess a singular form. Defaults to `false`.

#### python

> Removed in v1.17.0 and replaced by the [sqlc-gen-python](https://github.com/sqlc-dev/sqlc-gen-python) plugin. Follow the [migration guide](../guides/migrating-to-sqlc-gen-python) to switch.

- `package`:
  - The package name to use for the generated code.
- `out`:
  - Output directory for generated code.
- `emit_exact_table_names`:
  - If true, use the exact table name for generated models. Otherwise, guess a singular form. Defaults to `false`.
- `emit_sync_querier`:
  - If true, generate a class with synchronous methods. Defaults to `false`.
- `emit_async_querier`:
  - If true, generate a class with asynchronous methods. Defaults to `false`.
- `emit_pydantic_models`:
  - If true, generate classes that inherit from `pydantic.BaseModel`. Otherwise, define classes using the `dataclass` decorator. Defaults to `false`.

#### json

- `out`:
  - Output directory for the generated JSON.
- `filename`:
  - Filename for the generated JSON document. Defaults to `codegen_request.json`.
- `indent`:
  - Indent string to use in the JSON document. Defaults to `  `.

### plugins

Each mapping in the `plugins` collection has the following keys:

- `name`:
  - The name of this plugin. Required
- `env`
  - A list of environment variables to pass to the plugin. By default, no environment variables are passed.
- `process`: A mapping with a single `cmd` key
  - `cmd`:
    - The executable to call when using this plugin
  - `format`:
    - The format expected. Supports `json` and `protobuf` formats. Defaults to `protobuf`.
- `wasm`: A mapping with a two keys `url` and `sha256`
  - `url`:
    - The URL to fetch the WASM file. Supports the `https://` or `file://` schemes.
  - `sha256`
    - The SHA256 checksum for the downloaded file.
   
```yaml
version: "2"
plugins:
- name: "py"
  wasm: 
    url: "https://github.com/sqlc-dev/sqlc-gen-python/releases/download/v0.16.0-alpha/sqlc-gen-python.wasm"
    sha256: "428476c7408fd4c032da4ec74e8a7344f4fa75e0f98a5a3302f238283b9b95f2"
- name: "js"
  env:
  - PATH
  process: 
    cmd: "sqlc-gen-json"
```

### rules

Each mapping in the `rules` collection has the following keys:

- `name`:
  - The name of this rule. Required
- `rule`:
  - A [Common Expression Language (CEL)](https://github.com/google/cel-spec) expression. Required.
- `message`:
  - An optional message shown when this rule evaluates to `true`.

See the [vet](../howto/vet.md) documentation for a list of built-in rules and
help writing custom rules.
   
```yaml
version: "2"
sql:
  - schema: "query.sql"
    queries: "query.sql"
    engine: "postgresql"
    gen:
      go:
        package: "authors"
        out: "db"
    rules:
      - no-pg
      - no-delete
      - only-one-param
      - no-exec
rules:
  - name: no-pg
    message: "invalid engine: postgresql"
    rule: |
      config.engine == "postgresql"
  - name: no-delete
    message: "don't use delete statements"
    rule: |
      query.sql.contains("DELETE")
  - name: only-one-param
    message: "too many parameters"
    rule: |
      query.params.size() > 1
  - name: no-exec
    message: "don't use exec"
    rule: |
      query.cmd == "exec"
```
  
### Global overrides

Sometimes, the same configuration must be done across various specifications of
code generation.  Then a global definition for type overriding and field
renaming can be done using the `overrides` mapping the following manner:

```yaml
version: "2"
overrides:
  go:
    rename:
      id: "Identifier"
    overrides:
      - db_type: "timestamptz"
        nullable: true
        engine: "postgresql"
        go_type:
          import: "gopkg.in/guregu/null.v4"
          package: "null"
          type: "Time"
sql:
- schema: "postgresql/schema.sql"
  queries: "postgresql/query.sql"
  engine: "postgresql"
  gen:
    go: 
      package: "authors"
      out: "postgresql"
- schema: "mysql/schema.sql"
  queries: "mysql/query.sql"
  engine: "mysql"
  gen:
    go:
      package: "authors"
      out: "mysql"
```

With the previous configuration, whenever a struct field is generated from a
table column that is called `id`, it will generated as `Identifier`.

Also, whenever there is a nullable `timestamp with time zone` column in a
Postgres table, it will be generated as `null.Time`.  Note that the mapping for
global type overrides has a field called `engine` that is absent in the regular
type overrides. This field is only used when there are multiple definitions
using multiple engines. Otherwise, the value of the `engine` key
defaults to the engine that is currently being used.

Currently, type overrides and field renaming, both global and regular, are only
fully supported in Go.

## Version 1

```yaml
version: "1"
packages:
  - name: "db"
    path: "internal/db"
    queries: "./sql/query/"
    schema: "./sql/schema/"
    engine: "postgresql"
    emit_db_tags: false
    emit_prepared_queries: true
    emit_interface: false
    emit_exact_table_names: false
    emit_empty_slices: false
    emit_exported_queries: false
    emit_json_tags: true
    emit_result_struct_pointers: false
    emit_params_struct_pointers: false
    emit_methods_with_db_argument: false
    emit_pointers_for_null_types: false
    emit_enum_valid_method: false
    emit_all_enum_values: false
    build_tags: "some_tag"
    json_tags_case_style: "camel"
    omit_unused_structs: false
    output_batch_file_name: "batch.go"
    output_db_file_name: "db.go"
    output_models_file_name: "models.go"
    output_querier_file_name: "querier.go"
    output_copyfrom_file_name: "copyfrom.go"
    query_parameter_limit: 1
```

### packages

Each mapping in the `packages` collection has the following keys:

- `name`:
  - The package name to use for the generated code. Defaults to `path` basename.
- `path`:
  - Output directory for generated code.
- `queries`:
  - Directory of SQL queries or path to single SQL file; or a list of paths.
- `schema`:
  - Directory of SQL migrations or path to single SQL file; or a list of paths.
- `engine`:
  - Either `postgresql` or `mysql`. Defaults to `postgresql`.
- `sql_package`:
  - Either `pgx/v4`, `pgx/v5` or `database/sql`. Defaults to `database/sql`.
- `emit_db_tags`:
  - If true, add DB tags to generated structs. Defaults to `false`.
- `emit_prepared_queries`:
  - If true, include support for prepared queries. Defaults to `false`.
- `emit_interface`:
  - If true, output a `Querier` interface in the generated package. Defaults to `false`.
- `emit_exact_table_names`:
  - If true, struct names will mirror table names. Otherwise, sqlc attempts to singularize plural table names. Defaults to `false`.
- `emit_empty_slices`:
  - If true, slices returned by `:many` queries will be empty instead of `nil`. Defaults to `false`.
- `emit_exported_queries`:
  - If true, autogenerated SQL statement can be exported to be accessed by another package.
- `emit_json_tags`:
  - If true, add JSON tags to generated structs. Defaults to `false`.
- `emit_result_struct_pointers`:
  - If true, query results are returned as pointers to structs. Queries returning multiple results are returned as slices of pointers. Defaults to `false`.
- `emit_params_struct_pointers`:
  - If true, parameters are passed as pointers to structs. Defaults to `false`.
- `emit_methods_with_db_argument`:
  - If true, generated methods will accept a DBTX argument instead of storing a DBTX on the `*Queries` struct. Defaults to `false`.
- `emit_pointers_for_null_types`:
  - If true and `sql_package` is set to `pgx/v4` or `pgx/v5`, generated types for nullable columns are emitted as pointers (ie. `*string`) instead of `database/sql` null types (ie. `NullString`). Defaults to `false`.
- `emit_enum_valid_method`:
  - If true, generate a Valid method on enum types,
    indicating whether a string is a valid enum value.
- `emit_all_enum_values`:
  - If true, emit a function per enum type
    that returns all valid enum values.
- `build_tags`:
  - If set, add a `//go:build <build_tags>` directive at the beginning of each generated Go file.
- `json_tags_case_style`:
  - `camel` for camelCase, `pascal` for PascalCase, `snake` for snake_case or `none` to use the column name in the DB. Defaults to `none`.
- `omit_unused_structs`:
  - If `true`, sqlc won't generate table and enum structs that aren't used in queries for a given package. Defaults to `false`.
- `output_batch_file_name`:
  - Customize the name of the batch file. Defaults to `batch.go`.
- `output_db_file_name`:
  - Customize the name of the db file. Defaults to `db.go`.
- `output_models_file_name`:
  - Customize the name of the models file. Defaults to `models.go`.
- `output_querier_file_name`:
  - Customize the name of the querier file. Defaults to `querier.go`.
- `output_copyfrom_file_name`:
  - Customize the name of the copyfrom file. Defaults to `copyfrom.go`.
- `output_files_suffix`:
  - If specified the suffix will be added to the name of the generated files.
- `query_parameter_limit`:
  - Positional arguments that will be generated in Go functions (`>= 0`). To always emit a parameter struct, you would need to set it to `0`. Defaults to `1`.

### overrides

The default mapping of PostgreSQL/MySQL types to Go types only uses packages outside
the standard library when it must.

For example, the `uuid` PostgreSQL type is mapped to `github.com/google/uuid`.
If a different Go package for UUIDs is required, specify the package in the
`overrides` array. In this case, I'm going to use the `github.com/gofrs/uuid`
instead.

```yaml
version: "1"
packages: [...]
overrides:
  - go_type: "github.com/gofrs/uuid.UUID"
    db_type: "uuid"
```

Each override document has the following keys:

- `db_type`:
  - The PostgreSQL or MySQL type to override. Find the full list of supported types in [postgresql_type.go](https://github.com/sqlc-dev/sqlc/blob/main/internal/codegen/golang/postgresql_type.go#L12) or [mysql_type.go](https://github.com/sqlc-dev/sqlc/blob/main/internal/codegen/golang/mysql_type.go#L12). Note that for Postgres you must use the pg_catalog prefixed names where available.
- `go_type`:
  - A fully qualified name to a Go type to use in the generated code.
- `go_struct_tag`:
  - A reflect-style struct tag to use in the generated code, e.g. `a:"b" x:"y,z"`.
    If you want general json/db tags for all fields, use `emit_db_tags` and/or `emit_json_tags` instead.
- `nullable`:
  - If true, use this type when a column is nullable. Defaults to `false`.

Note that a single `db_type` override configuration applies to either nullable or non-nullable
columns, but not both. If you want a single `go_type` to override in both cases, you'll
need to specify two overrides.

For more complicated import paths, the `go_type` can also be an object.

```yaml
version: "1"
packages: [...]
overrides:
  - db_type: "uuid"
    go_type:
      import: "a/b/v2"
      package: "b"
      type: "MyType"
```

#### Per-Column Type Overrides

Sometimes you would like to override the Go type used in model or query generation for
a specific field of a table and not on a type basis as described in the previous section.

This may be configured by specifying the `column` property in the override definition. `column`
should be of the form `table.column` but you can be even more specific by specifying `schema.table.column`
or `catalog.schema.table.column`.

```yaml
version: "1"
packages: [...]
overrides:
  - column: "authors.id"
    go_type: "github.com/segmentio/ksuid.KSUID"
```

#### Package Level Overrides

Overrides can be configured globally, as demonstrated in the previous sections, or they can be configured per-package which
scopes the override behavior to just a single package:

```yaml
version: "1"
packages:
  - overrides: [...]
```

### rename

Struct field names are generated from column names using a simple algorithm:
split the column name on underscores and capitalize the first letter of each
part.

```
account     -> Account
spotify_url -> SpotifyUrl
app_id      -> AppID
```

If you're not happy with a field's generated name, use the `rename` mapping
to pick a new name. The keys are column names and the values are the struct
field name to use.

```yaml
version: "1"
packages: [...]
rename:
  spotify_url: "SpotifyURL"
```

================
File: docs/reference/datatypes.md
================
# Datatypes

`sqlc` attempts to make reasonable default choices when mapping internal
database types to Go types. Choices for more complex types are described below.

If you're unsatisfied with the default, you can override any type using the
[overrides list](config.md#type-overriding) in your `sqlc` config file.

## Arrays

PostgreSQL [arrays](https://www.postgresql.org/docs/current/arrays.html) are
materialized as Go slices.

```sql
CREATE TABLE places (
  name text   not null,
  tags text[]
);
```

```go
package db

type Place struct {
	Name string
	Tags []string
}
```

## Dates and times

All date and time types are returned as `time.Time` structs. For
null time or date values, the `NullTime` type from `database/sql` is used.

The `pgx/v5` sql package uses the appropriate pgx types.

For MySQL users relying on `github.com/go-sql-driver/mysql`, ensure that
`parseTime=true` is added to your database connection string.

```sql
CREATE TABLE authors (
  id         SERIAL    PRIMARY KEY,
  created_at timestamp NOT NULL DEFAULT NOW(),
  updated_at timestamp
);
```

```go
package db

import (
	"database/sql"
	"time"
)

type Author struct {
	ID        int
	CreatedAt time.Time
	UpdatedAt sql.NullTime
}
```

## Enums

PostgreSQL [enums](https://www.postgresql.org/docs/current/datatype-enum.html) are
mapped to an aliased string type.

```sql
CREATE TYPE status AS ENUM (
  'open',
  'closed'
);

CREATE TABLE stores (
  name   text    PRIMARY KEY,
  status status  NOT NULL
);
```

```go
package db

type Status string

const (
	StatusOpen   Status = "open"
	StatusClosed Status = "closed"
)

type Store struct {
	Name   string
	Status Status
}
```

## Null

For structs, null values are represented using the appropriate type from the
`database/sql` or `pgx` package.

```sql
CREATE TABLE authors (
  id   SERIAL PRIMARY KEY,
  name text   NOT NULL,
  bio  text
);
```

```go
package db

import (
	"database/sql"
)

type Author struct {
	ID   int
	Name string
	Bio  sql.NullString
}
```

## UUIDs

The Go standard library does not come with a `uuid` package. For UUID support,
sqlc uses the excellent `github.com/google/uuid` package. The pgx/v5 sql package uses `pgtype.UUID`.

```sql
CREATE TABLE records (
  id   uuid PRIMARY KEY
);
```

```go
package db

import (
	"github.com/google/uuid"
)

type Author struct {
	ID uuid.UUID
}
```

For MySQL, there is no native `uuid` data type. When using `UUID_TO_BIN` to store a `UUID()`, the underlying field type is `BINARY(16)` which by default sqlc would interpret this to `sql.NullString`. To have sqlc automatically convert these fields to a `uuid.UUID` type, use an overide on the column storing the `uuid`.
```json
{
  "overrides": [
    {
      "column": "*.uuid",
      "go_type": "github.com/google/uuid.UUID"
    }
  ]
}
```

## JSON

By default, sqlc will generate the `[]byte`, `pgtype.JSON` or `json.RawMessage` for JSON column type.
But if you use the `pgx/v5` sql package then you can specify a struct instead of default type.
The `pgx` implementation will marshal/unmarshal the struct automatically.

```go
package dto

type BookData struct {
	Genres    []string `json:"genres"`
	Title     string   `json:"title"`
	Published bool     `json:"published"`
}
```

```sql
CREATE TABLE books (
  data jsonb
);
```

```json
{
  "overrides": [
    {
      "column": "books.data",
      "go_type": {
        "import":"example/db",
        "package": "dto",
        "type":"BookData"
      }
    }
  ]
}
```

```go
package db

import (
	"example.com/db/dto"
)

type Book struct {
    Data *dto.BookData
}
```

## TEXT

In PostgreSQL, when you have a column with the TEXT type, sqlc will map it to a Go string by default. This default mapping applies to `TEXT` columns that are not nullable. However, for nullable `TEXT` columns, sqlc maps them to `pgtype.Text` when using the pgx/v5 driver. This distinction is crucial for developers looking to handle null values appropriately in their Go applications.

To accommodate nullable strings and map them to `*string` in Go, you can use the `emit_pointers_for_null_types` option in your sqlc configuration. This option ensures that nullable SQL columns are represented as pointer types in Go, allowing for a clear distinction between null and non-null values. Another way to do this is by passing the option `pointer: true` when you are overriding the `TEXT` datatype in you sqlc config file.

## Geometry

### PostGIS

#### Using `github.com/twpayne/go-geos` (pgx/v5 only)

sqlc can be configured to use the [geos](https://github.com/twpayne/go-geos)
package for working with PostGIS geometry types in [GEOS](https://libgeos.org/).

There are three steps:

1. Configure sqlc to use `*github.com/twpayne/go-geos.Geom` for geometry types.
2. Call `github.com/twpayne/pgx-geos.Register` on each
   `*github.com/jackc/pgx/v5.Conn`.
3. Annotate your SQL with `::geometry` typecasts, if needed.

```sql
-- Multipolygons in British National Grid (epsg:27700)
create table shapes(
  id serial,
  name varchar,
  geom geometry(Multipolygon, 27700)
);

-- name: GetCentroids :many
SELECT id, name, ST_Centroid(geom)::geometry FROM shapes;
```

```json
{
  "version": 2,
  "gen": {
    "go": {
      "overrides": [
        {
          "db_type": "geometry",
          "go_type": {
            "import": "github.com/twpayne/go-geos",
            "package": "geos",
            "pointer": true,
            "type": "Geom"
          },
          "nullable": true
        }
      ]
    }
  }
}
```

```go
import (
    "github.com/twpayne/go-geos"
    pgxgeos "github.com/twpayne/pgx-geos"
)

// ...

config.AfterConnect = func(ctx context.Context, conn *pgx.Conn) error {
    if err := pgxgeos.Register(ctx, conn, geos.NewContext()); err != nil {
        return err
    }
    return nil
}
```


#### Using `github.com/twpayne/go-geom`

sqlc can be configured to use the [geom](https://github.com/twpayne/go-geom)
package for working with PostGIS geometry types.

```sql
-- Multipolygons in British National Grid (epsg:27700)
create table shapes(
  id serial,
  name varchar,
  geom geometry(Multipolygon, 27700)
);

-- name: GetShapes :many
SELECT * FROM shapes;
```

```json
{
  "version": "1",
  "packages": [
    {
      "path": "db",
      "engine": "postgresql",
      "schema": "query.sql",
      "queries": "query.sql"
    }
  ],
  "overrides": [
    {
      "db_type": "geometry",
      "go_type": "github.com/twpayne/go-geom.MultiPolygon"
    },
    {
      "db_type": "geometry",
      "go_type": "github.com/twpayne/go-geom.MultiPolygon",
      "nullable": true
    }
  ]
}
```

================
File: docs/reference/environment-variables.md
================
# Environment variables

## SQLCCACHE

The `SQLCCACHE` environment variable dictates where `sqlc` will store cached
WASM-based plugins and modules. By default `sqlc` follows the [XDG Base
Directory
Specification](https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html).

## SQLCDEBUG

The `SQLCDEBUG` variable controls debugging variables within the runtime. It is
a comma-separated list of name=val pairs settings.

### dumpast

The `dumpast` command shows the SQL AST that was generated by the parser. Note
that this is the generic SQL AST, not the engine-specific SQL AST.

```
SQLCDEBUG=dumpast=1
```

```
([]interface {}) (len=1 cap=1) {
 (*catalog.Catalog)(0xc0004f48c0)({
  Comment: (string) "",
  DefaultSchema: (string) (len=6) "public",
  Name: (string) "",
  Schemas: ([]*catalog.Schema) (len=3 cap=4) {
   (*catalog.Schema)(0xc0004f4930)({
    Name: (string) (len=6) "public",
    Tables: ([]*catalog.Table) (len=1 cap=1) {
     (*catalog.Table)(0xc00052ff20)({
      Rel: (*ast.TableName)(0xc00052fda0)({
       Catalog: (string) "",
       Schema: (string) "",
       Name: (string) (len=7) "authors"
      }),
```

### dumpcatalog

The `dumpcatalog` command outputs the entire catalog. If you're using MySQL or
PostgreSQL, this can be a bit overwhelming. Expect this output to change in
future versions.

```
SQLCDEBUG=dumpcatalog=1
```

```
([]interface {}) (len=1 cap=1) {
 (*catalog.Catalog)(0xc00050d1f0)({
  Comment: (string) "",
  DefaultSchema: (string) (len=6) "public",
  Name: (string) "",
  Schemas: ([]*catalog.Schema) (len=3 cap=4) {
   (*catalog.Schema)(0xc00050d260)({
    Name: (string) (len=6) "public",
    Tables: ([]*catalog.Table) (len=1 cap=1) {
     (*catalog.Table)(0xc0000c0840)({
      Rel: (*ast.TableName)(0xc0000c06c0)({
       Catalog: (string) "",
       Schema: (string) "",
       Name: (string) (len=7) "authors"
      }),
```

### trace

The `trace` command is helpful for tracking down performance issues.

`SQLCDEBUG=trace=1`

By default, the trace output is written to `trace.out` in the current working
directory. You can configure a different path if needed.

`SQLCDEBUG=trace=name.out`

View the execution trace using the Go `trace` tool.

```
go tool trace trace.out
```

There's a ton of different views for the trace output, but here's an example
log showing the execution time for each package.

```
0.000043897 	 .         	1 	task sqlc (id 1, parent 0) created
0.000144923 	 .   101026 	1 	region generate started (duration: 47.619781ms)
0.001048975 	 .   904052 	1 	region package started (duration: 14.588456ms)
0.001054616 	 .     5641 	1 	name=authors dir=/Users/kyle/projects/sqlc/examples/python language=python
0.001071257 	 .    16641 	1 	region parse started (duration: 7.966549ms)
0.009043960 	 .  7972703 	1 	region codegen started (duration: 6.587086ms)
0.009171704 	 .   127744 	1 	new goroutine 35: text/template/parse.lex·dwrap·1
0.010361654 	 .  1189950 	1 	new goroutine 36: text/template/parse.lex·dwrap·1
0.015641815 	 .  5280161 	1 	region package started (duration: 10.904938ms)
0.015644943 	 .     3128 	1 	name=booktest dir=/Users/kyle/projects/sqlc/examples/python language=python
0.015647431 	 .     2488 	1 	region parse started (duration: 4.207749ms)
0.019860308 	 .  4212877 	1 	region codegen started (duration: 6.681624ms)
0.020028488 	 .   168180 	1 	new goroutine 37: text/template/parse.lex·dwrap·1
0.021020310 	 .   991822 	1 	new goroutine 8: text/template/parse.lex·dwrap·1
0.026551163 	 .  5530853 	1 	region package started (duration: 9.217294ms)
0.026554368 	 .     3205 	1 	name=jets dir=/Users/kyle/projects/sqlc/examples/python language=python
0.026556804 	 .     2436 	1 	region parse started (duration: 3.491005ms)
0.030051911 	 .  3495107 	1 	region codegen started (duration: 5.711931ms)
0.030213937 	 .   162026 	1 	new goroutine 20: text/template/parse.lex·dwrap·1
0.031099938 	 .   886001 	1 	new goroutine 38: text/template/parse.lex·dwrap·1
0.035772637 	 .  4672699 	1 	region package started (duration: 10.267039ms)
0.035775688 	 .     3051 	1 	name=ondeck dir=/Users/kyle/projects/sqlc/examples/python language=python
0.035778150 	 .     2462 	1 	region parse started (duration: 4.094518ms)
0.039877181 	 .  4099031 	1 	region codegen started (duration: 6.156341ms)
0.040010771 	 .   133590 	1 	new goroutine 39: text/template/parse.lex·dwrap·1
0.040894567 	 .   883796 	1 	new goroutine 40: text/template/parse.lex·dwrap·1
0.046042779 	 .  5148212 	1 	region writefiles started (duration: 1.718259ms)
0.047767781 	 .  1725002 	1 	task end
```

### processplugins

Setting this value to `0` disables process-based plugins. If a process-based
plugin is declared in the configuration file, running any `sqlc` command will
return an error.

`SQLCDEBUG=processplugins=0`

### dumpvetenv

The `dumpvetenv` command prints the variables available to a `sqlc vet` rule
during evaluation.

`SQLCDEBUG=dumpvetenv=1`

### dumpexplain

The `dumpexplain` command prints the JSON-formatted result from running
`EXPLAIN ...` on a query when a `sqlc vet` rule evaluation requires its output.

`SQLCDEBUG=dumpexplain=1`

## SQLCTMPDIR

If specified, use the given directory as the base for temporary folders. Only
applies when using WASM-based codegen plugins. When not specified, this
defaults to passing an empty string to
[`os.MkdirTemp`](https://pkg.go.dev/os#MkdirTemp).

================
File: docs/reference/language-support.rst
================
Database and language support
#############################

==========  =======================  ============  ============  ===============
Language    Plugin                   MySQL         PostgreSQL    SQLite
==========  =======================  ============  ============  ===============
Go          (built-in)               Stable        Stable        Beta
Go          `sqlc-gen-go`_           Stable        Stable        Beta
Kotlin      `sqlc-gen-kotlin`_       Beta          Beta          Not implemented
Python      `sqlc-gen-python`_       Beta          Beta          Not implemented
TypeScript  `sqlc-gen-typescript`_   Beta          Beta          Not implemented
==========  =======================  ============  ============  ===============

Community language support
**************************

New languages can be added via :doc:`plugins <../guides/plugins>`.

========  =================================  ===============  ===============  ===============
Language  Plugin                             MySQL            PostgreSQL       SQLite
========  =================================  ===============  ===============  ===============
C#        `DaredevilOSS/sqlc-gen-csharp`_    Stable           Stable           Stable
F#        `kaashyapan/sqlc-gen-fsharp`_      N/A              Beta             Beta
Java      `tandemdude/sqlc-gen-java`_        Beta             Beta             N/A 
PHP       `lcarilla/sqlc-plugin-php-dbal`_   Beta             N/A              N/A    
Ruby      `DaredevilOSS/sqlc-gen-ruby`_      Beta             Beta             Beta           
Zig       `tinyzimmer/sqlc-gen-zig`_         N/A              Beta             Beta            
[Any]     `fdietze/sqlc-gen-from-template`_  Stable           Stable           Stable
========  =================================  ===============  ===============  ===============

.. _sqlc-gen-go: https://github.com/sqlc-dev/sqlc-gen-go
.. _kaashyapan/sqlc-gen-fsharp: https://github.com/kaashyapan/sqlc-gen-fsharp
.. _sqlc-gen-kotlin: https://github.com/sqlc-dev/sqlc-gen-kotlin
.. _sqlc-gen-python: https://github.com/sqlc-dev/sqlc-gen-python
.. _sqlc-gen-typescript: https://github.com/sqlc-dev/sqlc-gen-typescript
.. _DaredevilOSS/sqlc-gen-csharp: https://github.com/DaredevilOSS/sqlc-gen-csharp
.. _DaredevilOSS/sqlc-gen-ruby: https://github.com/DaredevilOSS/sqlc-gen-ruby
.. _fdietze/sqlc-gen-from-template: https://github.com/fdietze/sqlc-gen-from-template
.. _lcarilla/sqlc-plugin-php-dbal: https://github.com/lcarilla/sqlc-plugin-php-dbal
.. _tandemdude/sqlc-gen-java: https://github.com/tandemdude/sqlc-gen-java
.. _tinyzimmer/sqlc-gen-zig: https://github.com/tinyzimmer/sqlc-gen-zig

Future language support
************************

================
File: docs/reference/macros.md
================
# Macros

## `sqlc.arg`

Attach a name to a parameter in a SQL query. This macro expands to an
engine-specific parameter placeholder. The name of the parameter is noted and
used during code generation.

```sql
-- name: GetAuthorByName :one
SELECT *
FROM authors
WHERE lower(name) = sqlc.arg(name);

-- >>> EXPANDS TO >>>

-- name: GetAuthorByName :one
SELECT *
FROM authors
WHERE lower(name) = ?;
```

See more examples in [Naming parameters](../howto/named_parameters).

## `sqlc.embed`

Embedding allows you to reuse existing model structs in more queries, resulting
in less manual serialization work. First, imagine we have the following schema
with students and test scores.

```sql
CREATE TABLE students (
  id   bigserial PRIMARY KEY,
  name text,
  age  integer
);

CREATE TABLE test_scores (
  student_id bigint,
  score integer,
  grade text
);
```

```sql
-- name: GetStudentAndScore :one
SELECT sqlc.embed(students), sqlc.embed(test_scores)
FROM students
JOIN test_scores ON test_scores.student_id = students.id
WHERE students.id = $1;

-- >>> EXPANDS TO >>>

-- name: GetStudentAndScore :one
SELECT students.*, test_scores.*
FROM students
JOIN test_scores ON test_scores.student_id = students.id
WHERE students.id = $1;
```

The Go method will return a struct with a field for the `Student` and field for
the test `TestScore` instead of each column existing on the struct.

```go
type GetStudentAndScoreRow struct {
	Student   Student
	TestScore TestScore
}

func (q *Queries) GetStudentAndScore(ctx context.Context, id int64) (GetStudentAndScoreRow, error) {
    // ...
}
```

See a full example in [Embedding structs](../howto/embedding).

## `sqlc.narg`

The same as `sqlc.arg`, but always marks the parameter as nullable.

```sql
-- name: GetAuthorByName :one
SELECT *
FROM authors
WHERE lower(name) = sqlc.narg(name);

-- >>> EXPANDS TO >>>

-- name: GetAuthorByName :one
SELECT *
FROM authors
WHERE LOWER(name) = ?;
```

See more examples in [Naming parameters](../howto/named_parameters).

## `sqlc.slice`

For drivers that do not support passing slices to the IN operator, the
`sqlc.slice` macro generates a dynamic query at runtime with the correct
number of parameters.

```sql
/* name: SelectStudents :many */
SELECT * FROM students 
WHERE age IN (sqlc.slice("ages"))

-- >>> EXPANDS TO >>>

/* name: SelectStudents :many */
SELECT id, name, age FROM authors 
WHERE age IN (/*SLICE:ages*/?)
```

Since the `/*SLICE:ages*/` placeholder is dynamically replaced on a per-query
basis, this macro can't be used with prepared statements.

See a full example in [Passing a slice as a parameter to a
query](../howto/select.md#mysql-and-sqlite).

================
File: docs/reference/query-annotations.md
================
# Query annotations

sqlc requires each query to have a small comment indicating the name and
command. The format of this comment is as follows:

```sql
-- name: <name> <command>
```

## `:exec`

The generated method will return the error from
[ExecContext](https://golang.org/pkg/database/sql/#DB.ExecContext).

```sql
-- name: DeleteAuthor :exec
DELETE FROM authors
WHERE id = $1;
```

```go
func (q *Queries) DeleteAuthor(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAuthor, id)
	return err
}
```

## `:execresult`

The generated method will return the [sql.Result](https://golang.org/pkg/database/sql/#Result) returned by
[ExecContext](https://golang.org/pkg/database/sql/#DB.ExecContext).

```sql
-- name: DeleteAllAuthors :execresult
DELETE FROM authors;
```

```go
func (q *Queries) DeleteAllAuthors(ctx context.Context) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteAllAuthors)
}
```

## `:execrows`

The generated method will return the number of affected rows from the
[result](https://golang.org/pkg/database/sql/#Result) returned by
[ExecContext](https://golang.org/pkg/database/sql/#DB.ExecContext).

```sql
-- name: DeleteAllAuthors :execrows
DELETE FROM authors;
```

```go
func (q *Queries) DeleteAllAuthors(ctx context.Context) (int64, error) {
	_, err := q.db.ExecContext(ctx, deleteAllAuthors)
	// ...
}
```

## `:execlastid`

The generated method will return the number generated by the database from the
[result](https://golang.org/pkg/database/sql/#Result) returned by
[ExecContext](https://golang.org/pkg/database/sql/#DB.ExecContext).

```sql
-- name: InsertAuthor :execlastid
INSERT INTO authors (name) VALUES (?);
```

```go
func (q *Queries) InsertAuthor(ctx context.Context, name string) (int64, error) {
	_, err := q.db.ExecContext(ctx, insertAuthor, name)
	// ...
}
```

## `:many`

The generated method will return a slice of records via
[QueryContext](https://golang.org/pkg/database/sql/#DB.QueryContext).

```sql
-- name: ListAuthors :many
SELECT * FROM authors
ORDER BY name;
```

```go
func (q *Queries) ListAuthors(ctx context.Context) ([]Author, error) {
	rows, err := q.db.QueryContext(ctx, listAuthors)
	// ...
}
```

## `:one`

The generated method will return a single record via
[QueryRowContext](https://golang.org/pkg/database/sql/#DB.QueryRowContext).

```sql
-- name: GetAuthor :one
SELECT * FROM authors
WHERE id = $1 LIMIT 1;
```

```go
func (q *Queries) GetAuthor(ctx context.Context, id int64) (Author, error) {
	row := q.db.QueryRowContext(ctx, getAuthor, id)
	// ...
}
```

## `:batchexec`

__NOTE: This command only works with PostgreSQL using the `pgx/v4` and `pgx/v5` drivers and outputting Go code.__

The generated method will return a batch object. The batch object will have
the following methods:
- `Exec`, that takes a `func(int, error)` parameter,
- `Close`, to close the batch operation early.

```sql
-- name: DeleteBook :batchexec
DELETE FROM books
WHERE book_id = $1;
```

```go
type DeleteBookBatchResults struct {
	br  pgx.BatchResults
	ind int
}

func (q *Queries) DeleteBook(ctx context.Context, bookID []int32) *DeleteBookBatchResults {
	//...
}
func (b *DeleteBookBatchResults) Exec(f func(int, error)) {
	//...
}
func (b *DeleteBookBatchResults) Close() error {
	//...
}
```

## `:batchmany`

__NOTE: This command only works with PostgreSQL using the `pgx/v4` and `pgx/v5` drivers and outputting Go code.__

The generated method will return a batch object. The batch object will have
the following methods:
- `Query`, that takes a `func(int, []T, error)` parameter, where `T` is your query's return type
- `Close`, to close the batch operation early.

```sql
-- name: BooksByTitleYear :batchmany
SELECT * FROM books
WHERE title = $1 AND year = $2;
```

```go
type BooksByTitleYearBatchResults struct {
	br  pgx.BatchResults
	ind int
}
type BooksByTitleYearParams struct {
	Title string `json:"title"`
	Year  int32  `json:"year"`
}

func (q *Queries) BooksByTitleYear(ctx context.Context, arg []BooksByTitleYearParams) *BooksByTitleYearBatchResults {
	//...
}
func (b *BooksByTitleYearBatchResults) Query(f func(int, []Book, error)) {
	//...
}
func (b *BooksByTitleYearBatchResults) Close() error {
	//...
}
```

## `:batchone`

__NOTE: This command only works with PostgreSQL using the `pgx/v4` and `pgx/v5` drivers and outputting Go code.__

The generated method will return a batch object. The batch object will have
the following methods:
- `QueryRow`, that takes a `func(int, T, error)` parameter, where `T` is your query's return type
- `Close`, to close the batch operation early.

```sql
-- name: CreateBook :batchone
INSERT INTO books (
    author_id,
    isbn
) VALUES (
    $1,
    $2
)
RETURNING book_id, author_id, isbn
```

```go
type CreateBookBatchResults struct {
	br  pgx.BatchResults
	ind int
}
type CreateBookParams struct {
	AuthorID int32  `json:"author_id"`
	Isbn     string `json:"isbn"`
}

func (q *Queries) CreateBook(ctx context.Context, arg []CreateBookParams) *CreateBookBatchResults {
	//...
}
func (b *CreateBookBatchResults) QueryRow(f func(int, Book, error)) {
	//...
}
func (b *CreateBookBatchResults) Close() error {
	//...
}
```

## `:copyfrom`

__NOTE: This command is driver and package specific, see [how to insert](../howto/insert.md#using-copyfrom)

This command is used to insert rows a lot faster than sequential inserts.

================
File: docs/tutorials/getting-started-mysql.md
================
# Getting started with MySQL

This tutorial assumes that the latest version of sqlc is
[installed](../overview/install.md) and ready to use.

We'll generate Go code here, but other
[language plugins](../reference/language-support.rst) are available. You'll
naturally need the Go toolchain if you want to build and run a program with the
code sqlc generates, but sqlc itself has no dependencies.

At the end, you'll push your SQL queries to [sqlc Cloud](https://dashboard.sqlc.dev/) for further insights and analysis.

## Setting up

Create a new directory called `sqlc-tutorial` and open it up.

Initialize a new Go module named `tutorial.sqlc.dev/app`

```shell
go mod init tutorial.sqlc.dev/app
```

sqlc looks for either a `sqlc.(yaml|yml)` or `sqlc.json` file in the current
directory. In our new directory, create a file named `sqlc.yaml` with the
following contents:

```yaml
version: "2"
sql:
  - engine: "mysql"
    queries: "query.sql"
    schema: "schema.sql"
    gen:
      go:
        package: "tutorial"
        out: "tutorial"
```

## Schema and queries

sqlc needs to know your database schema and queries in order to generate code.
In the same directory, create a file named `schema.sql` with the following
content:

```sql
CREATE TABLE authors (
  id   BIGINT  NOT NULL AUTO_INCREMENT PRIMARY KEY,
  name text    NOT NULL,
  bio  text
);
```

Next, create a `query.sql` file with the following four queries:

```sql
-- name: GetAuthor :one
SELECT * FROM authors
WHERE id = ? LIMIT 1;

-- name: ListAuthors :many
SELECT * FROM authors
ORDER BY name;

-- name: CreateAuthor :execresult
INSERT INTO authors (
  name, bio
) VALUES (
  ?, ?
);

-- name: DeleteAuthor :exec
DELETE FROM authors
WHERE id = ?;
```

## Generating code

You are now ready to generate code. You shouldn't see any output when you run
the `generate` subcommand, unless something goes wrong:

```shell
sqlc generate
```

You should now have a `tutorial` subdirectory with three files containing Go
source code. These files comprise a Go package named `tutorial`:

```
├── go.mod
├── query.sql
├── schema.sql
├── sqlc.yaml
└── tutorial
    ├── db.go
    ├── models.go
    └── query.sql.go
```

## Using generated code

You can use your newly-generated `tutorial` package from any Go program.
Create a file named `tutorial.go` and add the following contents:

```go
package main

import (
	"context"
	"database/sql"
	"log"
	"reflect"

	_ "github.com/go-sql-driver/mysql"

	"tutorial.sqlc.dev/app/tutorial"
)

func run() error {
	ctx := context.Background()

	db, err := sql.Open("mysql", "user:password@/dbname?parseTime=true")
	if err != nil {
		return err
	}

	queries := tutorial.New(db)

	// list all authors
	authors, err := queries.ListAuthors(ctx)
	if err != nil {
		return err
	}
	log.Println(authors)

	// create an author
	result, err := queries.CreateAuthor(ctx, tutorial.CreateAuthorParams{
		Name: "Brian Kernighan",
		Bio:  sql.NullString{String: "Co-author of The C Programming Language and The Go Programming Language", Valid: true},
	})
	if err != nil {
		return err
	}

	insertedAuthorID, err := result.LastInsertId()
	if err != nil {
		return err
	}
	log.Println(insertedAuthorID)

	// get the author we just inserted
	fetchedAuthor, err := queries.GetAuthor(ctx, insertedAuthorID)
	if err != nil {
		return err
	}

	// prints true
	log.Println(reflect.DeepEqual(insertedAuthorID, fetchedAuthor.ID))
	return nil
}

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}
```

Before this code will compile you'll need to fetch the relevant MySQL driver:

```shell
go get github.com/go-sql-driver/mysql
go build ./...
```

The program should compile without errors. To make that possible, sqlc generates
readable, **idiomatic** Go code that you otherwise would've had to write
yourself. Take a look in `tutorial/query.sql.go`.

Of course for this program to run successfully you'll need
to compile after replacing the database connection parameters in the call to
`sql.Open()` with the correct parameters for your database. And your
database must have the `authors` table as defined in `schema.sql`.

You should now have a working program using sqlc's generated Go source code,
and hopefully can see how you'd use sqlc in your own real-world applications.

## Query verification

[sqlc Cloud](https://dashboard.sqlc.dev) provides additional verification, catching subtle bugs. To get started, create a
[dashboard account](https://dashboard.sqlc.dev). Once you've signed in, create a
project and generate an auth token. Add your project's ID to the `cloud` block
to your sqlc.yaml.


```yaml
version: "2"
cloud:
  # Replace <PROJECT_ID> with your project ID from the sqlc Cloud dashboard
  project: "<PROJECT_ID>"
sql:
  - engine: "mysql"
    queries: "query.sql"
    schema: "schema.sql"
    gen:
      go:
        package: "tutorial"
        out: "tutorial"
```

Replace `<PROJECT_ID>` with your project ID from the sqlc Cloud dashboard. It
will look something like `01HA8SZH31HKYE9RR3N3N3TSJM`.

And finally, set the `SQLC_AUTH_TOKEN` environment variable:

```shell
export SQLC_AUTH_TOKEN="<your sqlc auth token>"
```

```shell
$ sqlc push --tag tutorial
```

================
File: docs/tutorials/getting-started-postgresql.md
================
# Getting started with PostgreSQL

This tutorial assumes that the latest version of sqlc is
[installed](../overview/install.md) and ready to use.

We'll generate Go code here, but other
[language plugins](../reference/language-support.rst) are available. You'll
naturally need the Go toolchain if you want to build and run a program with the
code sqlc generates, but sqlc itself has no dependencies.

At the end, you'll push your SQL queries to [sqlc
Cloud](https://dashboard.sqlc.dev/) for further insights and analysis.

## Setting up

Create a new directory called `sqlc-tutorial` and open it up.

Initialize a new Go module named `tutorial.sqlc.dev/app`:

```shell
go mod init tutorial.sqlc.dev/app
```

sqlc looks for either a `sqlc.(yaml|yml)` or `sqlc.json` file in the current
directory. In our new directory, create a file named `sqlc.yaml` with the
following contents:

```yaml
version: "2"
sql:
  - engine: "postgresql"
    queries: "query.sql"
    schema: "schema.sql"
    gen:
      go:
        package: "tutorial"
        out: "tutorial"
        sql_package: "pgx/v5"
```

## Schema and queries

sqlc needs to know your database schema and queries in order to generate code.
In the same directory, create a file named `schema.sql` with the following
content:

```sql
CREATE TABLE authors (
  id   BIGSERIAL PRIMARY KEY,
  name text      NOT NULL,
  bio  text
);
```

Next, create a `query.sql` file with the following five queries:

```sql
-- name: GetAuthor :one
SELECT * FROM authors
WHERE id = $1 LIMIT 1;

-- name: ListAuthors :many
SELECT * FROM authors
ORDER BY name;

-- name: CreateAuthor :one
INSERT INTO authors (
  name, bio
) VALUES (
  $1, $2
)
RETURNING *;

-- name: UpdateAuthor :exec
UPDATE authors
  set name = $2,
  bio = $3
WHERE id = $1;

-- name: DeleteAuthor :exec
DELETE FROM authors
WHERE id = $1;
```

If you prefer, you can alter the `UpdateAuthor` query to return the updated
record:

```sql
-- name: UpdateAuthor :one
UPDATE authors
  set name = $2,
  bio = $3
WHERE id = $1
RETURNING *;
```

## Generating code

You are now ready to generate code. You shouldn't see any output when you run
the `generate` subcommand, unless something goes wrong:

```shell
sqlc generate
```

You should now have a `tutorial` subdirectory with three files containing Go
source code. These files comprise a Go package named `tutorial`:

```
├── go.mod
├── query.sql
├── schema.sql
├── sqlc.yaml
└── tutorial
    ├── db.go
    ├── models.go
    └── query.sql.go
```

## Using generated code

You can use your newly-generated `tutorial` package from any Go program.
Create a file named `tutorial.go` and add the following contents:

```go
package main

import (
	"context"
	"log"
	"reflect"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"

	"tutorial.sqlc.dev/app/tutorial"
)

func run() error {
	ctx := context.Background()

	conn, err := pgx.Connect(ctx, "user=pqgotest dbname=pqgotest sslmode=verify-full")
	if err != nil {
		return err
	}
	defer conn.Close(ctx)

	queries := tutorial.New(conn)

	// list all authors
	authors, err := queries.ListAuthors(ctx)
	if err != nil {
		return err
	}
	log.Println(authors)

	// create an author
	insertedAuthor, err := queries.CreateAuthor(ctx, tutorial.CreateAuthorParams{
		Name: "Brian Kernighan",
		Bio:  pgtype.Text{String: "Co-author of The C Programming Language and The Go Programming Language", Valid: true},
	})
	if err != nil {
		return err
	}
	log.Println(insertedAuthor)

	// get the author we just inserted
	fetchedAuthor, err := queries.GetAuthor(ctx, insertedAuthor.ID)
	if err != nil {
		return err
	}

	// prints true
	log.Println(reflect.DeepEqual(insertedAuthor, fetchedAuthor))
	return nil
}

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}
```

Before this code will compile you'll need to fetch the relevant PostgreSQL
driver. You can use `lib/pq` with the standard library's `database/sql`
package, but in this tutorial we've used `pgx/v5`:

```shell
go get github.com/jackc/pgx/v5
go build ./...
```

The program should compile without errors. To make that possible, sqlc generates
readable, **idiomatic** Go code that you otherwise would've had to write
yourself. Take a look in `tutorial/query.sql.go`.

Of course for this program to run successfully you'll need
to compile after replacing the database connection parameters in the call to
`pgx.Connect()` with the correct parameters for your database. And your
database must have the `authors` table as defined in `schema.sql`.

You should now have a working program using sqlc's generated Go source code,
and hopefully can see how you'd use sqlc in your own real-world applications.

## Query verification

[sqlc Cloud](https://dashboard.sqlc.dev) provides additional verification, catching subtle bugs. To get started, create a
[dashboard account](https://dashboard.sqlc.dev). Once you've signed in, create a
project and generate an auth token. Add your project's ID to the `cloud` block
to your sqlc.yaml.

```yaml
version: "2"
cloud:
  # Replace <PROJECT_ID> with your project ID from the sqlc Cloud dashboard
  project: "<PROJECT_ID>"
sql:
  - engine: "postgresql"
    queries: "query.sql"
    schema: "schema.sql"
    gen:
      go:
        package: "tutorial"
        out: "tutorial"
        sql_package: "pgx/v5"
```

Replace `<PROJECT_ID>` with your project ID from the sqlc Cloud dashboard. It
will look something like `01HA8SZH31HKYE9RR3N3N3TSJM`.

And finally, set the `SQLC_AUTH_TOKEN` environment variable:

```shell
export SQLC_AUTH_TOKEN="<your sqlc auth token>"
```

```shell
$ sqlc push --tag tutorial
```

In the sidebar, go to the "Queries" section to see your published queries. Run
`verify` to ensure that previously published queries continue to work against
updated database schema.

```shell
$ sqlc verify --against tutorial
```

================
File: docs/tutorials/getting-started-sqlite.md
================
# Getting started with SQLite

This tutorial assumes that the latest version of sqlc is
[installed](../overview/install.md) and ready to use.

We'll generate Go code here, but other
[language plugins](../reference/language-support.rst) are available. You'll
naturally need the Go toolchain if you want to build and run a program with the
code sqlc generates, but sqlc itself has no dependencies.

## Setting up

Create a new directory called `sqlc-tutorial` and open it up.

Initialize a new Go module named `tutorial.sqlc.dev/app`

```shell
go mod init tutorial.sqlc.dev/app
```

sqlc looks for either a `sqlc.(yaml|yml)` or `sqlc.json` file in the current
directory. In our new directory, create a file named `sqlc.yaml` with the
following contents:

```yaml
version: "2"
sql:
  - engine: "sqlite"
    queries: "query.sql"
    schema: "schema.sql"
    gen:
      go:
        package: "tutorial"
        out: "tutorial"
```

## Schema and queries

sqlc needs to know your database schema and queries in order to generate code.
In the same directory, create a file named `schema.sql` with the following
content:

```sql
CREATE TABLE authors (
  id   INTEGER PRIMARY KEY,
  name text    NOT NULL,
  bio  text
);
```

Next, create a `query.sql` file with the following five queries:

```sql
-- name: GetAuthor :one
SELECT * FROM authors
WHERE id = ? LIMIT 1;

-- name: ListAuthors :many
SELECT * FROM authors
ORDER BY name;

-- name: CreateAuthor :one
INSERT INTO authors (
  name, bio
) VALUES (
  ?, ?
)
RETURNING *;

-- name: UpdateAuthor :exec
UPDATE authors
set name = ?,
bio = ?
WHERE id = ?;

-- name: DeleteAuthor :exec
DELETE FROM authors
WHERE id = ?;
```

If you prefer, you can alter the `UpdateAuthor` query to return the updated
record:

```sql
-- name: UpdateAuthor :one
UPDATE authors
set name = ?,
bio = ?
WHERE id = ?
RETURNING *;
```

## Generating code

You are now ready to generate code. You shouldn't see any output when you run
the `generate` subcommand, unless something goes wrong:

```shell
sqlc generate
```

You should now have a `tutorial` subdirectory with three files containing Go
source code. These files comprise a Go package named `tutorial`:

```
├── go.mod
├── query.sql
├── schema.sql
├── sqlc.yaml
└── tutorial
    ├── db.go
    ├── models.go
    └── query.sql.go
```

## Using generated code

You can use your newly-generated `tutorial` package from any Go program.
Create a file named `tutorial.go` and add the following contents:

```go
package main

import (
	"context"
	"database/sql"
	_ "embed"
	"log"
	"reflect"

	_ "modernc.org/sqlite"

	"tutorial.sqlc.dev/app/tutorial"
)

//go:embed schema.sql
var ddl string

func run() error {
	ctx := context.Background()

	db, err := sql.Open("sqlite", ":memory:")
	if err != nil {
		return err
	}

	// create tables
	if _, err := db.ExecContext(ctx, ddl); err != nil {
		return err
	}

	queries := tutorial.New(db)

	// list all authors
	authors, err := queries.ListAuthors(ctx)
	if err != nil {
		return err
	}
	log.Println(authors)

	// create an author
	insertedAuthor, err := queries.CreateAuthor(ctx, tutorial.CreateAuthorParams{
		Name: "Brian Kernighan",
		Bio:  sql.NullString{String: "Co-author of The C Programming Language and The Go Programming Language", Valid: true},
	})
	if err != nil {
		return err
	}
	log.Println(insertedAuthor)

	// get the author we just inserted
	fetchedAuthor, err := queries.GetAuthor(ctx, insertedAuthor.ID)
	if err != nil {
		return err
	}

	// prints true
	log.Println(reflect.DeepEqual(insertedAuthor, fetchedAuthor))
	return nil
}

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}
```

Before this code will compile you'll need to fetch the relevant SQLite driver:

```shell
go get modernc.org/sqlite
go build ./...
```

The program should compile without errors, and run successfully. To make that
possible, sqlc generates readable, **idiomatic** Go code that you
otherwise would've had to write yourself. Take a look in `tutorial/query.sql.go`.

You should now have a working program using sqlc's generated Go source code,
and hopefully can see how you'd use sqlc in your own real-world applications.

================
File: docs/.gitignore
================
_venv
_build

================
File: docs/conf.py
================
# Configuration file for the Sphinx documentation builder.
#
# This file only contains a selection of the most common options. For a full
# list see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html

# -- Path setup --------------------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#
import os
# import sys
# sys.path.insert(0, os.path.abspath('.'))
import sphinx_rtd_theme

# -- Project information -----------------------------------------------------

project = 'sqlc'
copyright = '2024, Riza, Inc.'
author = 'Riza, Inc.'

# The full version, including alpha/beta/rc tags
release = '1.28.0'


# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'myst_parser',
    'sphinx_rtd_theme',
    'sphinx_favicon',
    'sphinxext.rediraffe',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = ['_build', '_venv', 'Thumbs.db', '.DS_Store']

# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = 'sphinx_rtd_theme'

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

html_logo = "_static/logo.png"
html_theme_options = {
    'logo_only': True,
}

html_context = {
    'show_banner': 'SHOW_LAUNCH_BANNER' in os.environ,
}

def setup(app):
    app.add_css_file('customize.css')

favicons = [
    "favicon.png",
]

myst_enable_extensions = [
    "attrs_inline",
    "colon_fence",
]

rediraffe_redirects = {
    "howto/upload.md": "howto/push.md",
}

================
File: docs/index.rst
================
.. sqlc documentation master file, created by
   sphinx-quickstart on Mon Feb  1 23:18:36 2021.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

sqlc Documentation
==================

  And lo, the Great One looked down upon the people and proclaimed:
    "SQL is actually pretty great"

sqlc generates **fully type-safe idiomatic Go code** from SQL. Here's how it
works:

1. You write SQL queries
2. You run sqlc to generate Go code that presents type-safe interfaces to those
   queries
3. You write application code that calls the methods sqlc generated

Seriously, it's that easy. You don't have to write any boilerplate SQL querying
code ever again.

.. toctree::
   :maxdepth: 2
   :caption: Overview
   :hidden:

   overview/install.md

.. toctree::
   :maxdepth: 2
   :caption: Tutorials
   :hidden:

   tutorials/getting-started-mysql.md
   tutorials/getting-started-postgresql.md
   tutorials/getting-started-sqlite.md

.. toctree::
   :maxdepth: 2
   :caption: Commands
   :hidden:

   howto/generate.md
   howto/push.md
   howto/verify.md
   howto/vet.md

.. toctree::
   :maxdepth: 2
   :caption: How-to Guides
   :hidden:

   howto/select.md
   howto/query_count.md
   howto/insert.md
   howto/update.md
   howto/delete.md

   howto/prepared_query.md
   howto/transactions.md
   howto/named_parameters.md

   howto/ddl.md
   howto/structs.md
   howto/embedding.md
   howto/overrides.md
   howto/rename.md

.. toctree::
   :maxdepth: 3
   :caption: sqlc Cloud
   :hidden:

   howto/managed-databases.md

.. toctree::
   :maxdepth: 3
   :caption: Reference
   :hidden:

   reference/changelog.md
   reference/cli.md
   reference/config.md
   reference/datatypes.md
   reference/environment-variables.md
   reference/language-support.rst
   reference/macros.md
   reference/query-annotations.md

.. toctree::
   :maxdepth: 2
   :caption: Conceptual Guides
   :hidden:

   howto/ci-cd.md
   guides/using-go-and-pgx.rst
   guides/plugins.md
   guides/development.md
   guides/privacy.md

================
File: docs/Makefile
================
# Minimal makefile for Sphinx documentation
#

# You can set these variables from the command line, and also
# from the environment for the first two.
SPHINXOPTS    ?=
VENVDIR       = _venv
BINDIR        = $(VENVDIR)/bin
SPHINXBUILD   = $(BINDIR)/sphinx-build
SOURCEDIR     = .
BUILDDIR      = _build

# Put it first so that "make" without argument is like "make help".
help: $(SPHINXBUILD)
	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

$(SPHINXBUILD): $(VENVDIR)
	$(VENVDIR)/bin/pip install -r requirements.txt

$(VENVDIR):
	python3 -m venv $(VENVDIR)

.PHONY: help Makefile

# Catch-all target: route all unknown targets to Sphinx using the new
# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
%: Makefile
	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

================
File: docs/requirements.txt
================
Babel==2.17.0
Jinja2==3.1.6
MarkupSafe==3.0.2
Pygments==2.19.1
Sphinx==7.4.7
certifi==2025.1.31
chardet==5.2.0
commonmark==0.9.1
docutils==0.20.1
idna==3.10
imagesize==1.4.1
myst-parser==4.0.1 
packaging==24.2
pyparsing==3.2.3
pytz==2025.2
requests==2.32.3
snowballstemmer==2.2.0
sphinx-favicon==1.0.1
sphinx-rtd-theme==3.0.2
sphinxcontrib-applehelp==2.0.0
sphinxcontrib-devhelp==2.0.0
sphinxcontrib-htmlhelp==2.1.0
sphinxcontrib-jsmath==1.0.1
sphinxcontrib-qthelp==2.0.0
sphinxcontrib-serializinghtml==2.0.0
sphinxext-rediraffe==0.2.7
urllib3==2.3.0



================================================================
End of Codebase
================================================================
